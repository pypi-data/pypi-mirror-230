# Copyright (c) 2023 sylk.build

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from sylk.commons import file_system


gitignore_py = "# Byte-compiled / optimized / DLL files\n\
__pycache__/\n\
*.py[cod]\n\
*$py.class\n\n\
# C extensions\n\
*.so\n\n\
# Distribution / packaging\n\
.Python\n\
build/\n\
develop-eggs/\n\
dist/\n\
downloads/\n\
eggs/\n\
.eggs/\n\
lib/\n\
lib64/\n\
parts/\n\
sdist/\n\
var/\n\
wheels/\n\
share/python-wheels/\n\
*.egg-info/\n\
.installed.cfg\n\
*.egg\n\
MANIFEST\n\n\
# PyInstaller\n\
#  Usually these files are written by a python script from a template\n\
#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n\
*.manifest\n\
*.spec\n\n\
# Installer logs\n\
pip-log.txt\n\
pip-delete-this-directory.txt\n\
# Unit test / coverage reports\n\
htmlcov/\n\
.tox/\n\
.nox/\n\
.coverage\n\
.coverage.*\n\
.cache\n\
nosetests.xml\n\
coverage.xml\n\
*.cover\n\
*.py,cover\n\
.hypothesis/\n\
.pytest_cache/\n\
cover/\n\n\
# Translations\n\
*.mo\n\
*.pot\n\
# sylk stuff:\n\
.sylk/\n\
# Flask stuff:\n\
instance/\n\
.webassets-cache\n\
# Scrapy stuff:\n\
.scrapy\n\
# Sphinx documentation\n\
docs/_build/\n\
# PyBuilder\n\
.pybuilder/\n\
target/\n\
# Jupyter Notebook\n\
.ipynb_checkpoints\n\
# IPython\n\
profile_default/\n\
ipython_config.py\n\n\
# Environments\n\n\
.env\n\
.venv\n\
env/\n\
venv/\n\
ENV/\n\
env.bak/\n\
venv.bak/\n"

gitignore_go = "# If you prefer the allow list template instead of the deny list, see community template:\n\
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n\
#\n\
# Binaries for programs and plugins\n\
*.exe\n\
*.exe~\n\
*.dll\n\
*.so\n\
*.dylib\n\n\
# Test binary, built with `go test -c`\n\
*.test\n\n\
# Output of the go coverage tool, specifically when used with LiteIDE\n\
*.out\n\n\
# Dependency directories (remove the comment below to include it)\n\n\
# vendor/\n\n\
# Go workspace file\n\
go.work"

gitignore_js = "# Logs\n\
logs\n\
*.log\n\
npm-debug.log*\n\
yarn-debug.log*\n\
yarn-error.log*\n\
lerna-debug.log*\n\
.pnpm-debug.log*\n\n\
# Diagnostic reports (https://nodejs.org/api/report.html)\n\
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n\
# Runtime data\n\
pids\n\
*.pid\n\
*.seed\n\
*.pid.lock\n\n\
# Directory for instrumented libs generated by jscoverage/JSCover\n\
lib-cov\n\n\
# Coverage directory used by tools like istanbul\n\
coverage\n\
*.lcov\n\n\
# nyc test coverage\n\
.nyc_output\n\n\
# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n\
.grunt\n\n\
# Bower dependency directory (https://bower.io/)\n\
bower_components\n\n\
# node-waf configuration\n\n\
.lock-wscript\n\
# Compiled binary addons (https://nodejs.org/api/addons.html)\n\
build/Release\n\n\
# Dependency directories\n\
node_modules/\n\
jspm_packages/\n\n\
# Snowpack dependency directory (https://snowpack.dev/)\n\
web_modules/\n\n\
# TypeScript cache\n\
*.tsbuildinfo\n\n\
# Optional npm cache directory\n\
.npm\n\n\
# Optional eslint cache\n\
.eslintcache\n\n\
# Optional stylelint cache\n\
.stylelintcache\n\n\
# dotenv environment variable files\n\
.env\n\
.env.development.local\n\
.env.test.local\n\
.env.production.local\n\
.env.local\n\n\
# yarn v2\n\
.yarn/cache\n\
.yarn/unplugged\n\
.yarn/build-state.yml\n\
.yarn/install-state.gz\n\
.pnp.*\n"

gitignore_ts = "lib-cov\n\
*.seed\n\
*.log\n\
*.csv\n\
*.dat\n\
*.out\n\
*.pid\n\
*.gz\n\
*.swp\n\n\
pids\n\
logs\n\
results\n\
tmp\n\n\
# Build\n\
public/css/main.css\n\n\
# Coverage reports\n\n\
coverage\n\n\
# API keys and secrets\n\
.env\n\n\
# Dependency directory\n\
node_modules\n\
bower_components\n\n\
# Editors\n\
.idea\n\
*.iml\n\
# OS metadata\n\
.DS_Store\n\
Thumbs.db\n\n\
# Ignore built ts files\n\
dist/**/*\n\
# ignore yarn.lock\n\
yarn.lock\n\n\
.sylk\n"
_OPEN_BRCK = "{"
_CLOSING_BRCK = "}"


def bash_init_script_go(project_package, services, packages):
    services_protoc = []
    packages_protoc = []
    # for s in services:
    #     services_protoc.append('mkdir $DST_DIR"/{0}"\nprotoc -I=$SRC_DIR --go_out=$DST_DIR --go_opt=paths=source_relative --go-grpc_out=$DST_DIR"/{0}"  --go-grpc_opt=paths=source_relative protos/{0}.proto'.format(s))
    # for p in packages:
    #     packages_protoc.append('mkdir $DST_DIR"/{0}"\nprotoc -I=$SRC_DIR --go_out=$DST_DIR --go_opt=paths=source_relative --go-grpc_out=$DST_DIR"/{0}"  --go-grpc_opt=paths=source_relative protos/{0}.proto'.format(p))
    return '#!/bin/bash\n\n\
echo "[sylk.build] init.sh starting protoc compiler for Go"\n\
go get -u google.golang.org/protobuf\n\
go get -u google.golang.org/grpc\n\
SRC_DIR="protos"\n\
DST_DIR="services/protos"\n\
{1}\n\
{2}\n\
go mod tidy\n\
go test\n\
statuscode=$?\n\
echo "Exit code for go.mod tidy and test -> "$statuscode\n\
[[ "$statuscode" != "0" ]] && {3} echo "Some error occured during init script for Go"; echo "Running init for : {0}"; go mod init {0}; {4}\n'.format(
        project_package,
        "\n".join(services_protoc),
        "\n".join(packages_protoc),
        _OPEN_BRCK,
        _CLOSING_BRCK,
    )


bash_init_script_ts = '#!/bin/bash\n\n\
echo "[sylk.build] init.sh starting protoc compiler"\n\
npm i\n\
node ./bin/proto.js\n\
npm run build\n\
statuscode=$?\n\
echo "Exit code for protoc -> "$statuscode\n\
[[ "$statuscode" != "0" ]] && { echo "Some error occured during init script"; exit 1; }\n\
exit 0'

bash_init_script_webpack = '#!/bin/bash\n\
declare -a services=("protos")\n\
for SERVICE in "${0}services[@]{1}"; do\n\
    echo $SERVICE\n\
    cd $SERVICE\n\
    for FILE in *; do\n\
        filename=$FILE\n\
        search="protos\/"\n\
        replace=""\n\
        sed -i\'.bak\' -e "1,8 s/$search/$replace/gi" $filename\n\
        rm -f *.bak\n\
        echo "[sylk-script] Compiling -> "$filename\n\
        sudo protoc -I=../protos $filename  --js_out=import_style=commonjs,binary:../clients/webpack   --grpc-web_out=import_style=typescript,mode=grpcwebtext:../clients/webpack\n\
    done\n\
done'.format(
    _OPEN_BRCK, _CLOSING_BRCK
)

def bash_run_server_script_ts(code_base_path: str):
    return '#!/bin/bash\n\n\
if [[ $1 == "debug" ]]\n\
then\n\
\techo "Debug mode: $1"\n\
\tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all node {0}\n\
elif [[ $1 == "info" ]]\n\
then\n\
\techo "Info Mode: $1"\n\
\tGRPC_VERBOSITY=INFO GRPC_TRACE=all node {0}\n\
else\n\
\tnode {0}\n\
fi'.format(file_system.join_path('.','dist','server.js'))

def protos_compile_script_ts(code_base_path: str):
    code_base_path = f"{code_base_path}/" if code_base_path is not None and code_base_path != '' else ''
    return f'const path = require("path");\n\
const {_OPEN_BRCK} execSync {_CLOSING_BRCK} = require("child_process");\n\
const rimraf = require("rimraf");\n\n\
const PROTO_DIR = path.join(__dirname, "../protos");\n\
const MODEL_DIR = path.join(__dirname, "../{code_base_path}services/protos");\n\
const PROTOC_PATH = path.join(__dirname, "../node_modules/grpc-tools/bin/protoc");\n\
const PLUGIN_PATH = path.join(__dirname, "../node_modules/.bin/protoc-gen-ts_proto");\n\n\
const pkgJson = require("../sylk.json");\n\
let protos = [];\n\n\
function getUniqueStrings(arr) {_OPEN_BRCK}\n\
  const uniqueSet = new Set(arr);\n\
  return Array.from(uniqueSet).filter(u => u !== undefined);\n\
{_CLOSING_BRCK}\n\n\
for (const pkg in pkgJson.packages) {_OPEN_BRCK}\n\
  if (Object.hasOwnProperty.call(pkgJson.packages, pkg)) {_OPEN_BRCK}\n\
    let files = [];\n\
    let standaloneFile = false;\n\
    if(pkgJson.packages[pkg].services) {_OPEN_BRCK}\n\
      pkgJson.packages[pkg]?.services.map(s => s.tag).map(s => files.push(s))\n\
      if(pkgJson.packages[pkg]?.services.map(s => !s.tag).includes(true)) {_OPEN_BRCK}\n\
        standaloneFile = true;\n\
      {_CLOSING_BRCK}\n\
    {_CLOSING_BRCK}\n\
    if(pkgJson.packages[pkg].messages) {_OPEN_BRCK}\n\
      pkgJson.packages[pkg]?.messages.map(m => m.tag).map(m => files.push(m))\n\
      if(pkgJson.packages[pkg]?.messages.map(m => !m.tag).includes(true)) {_OPEN_BRCK}\n\
        standaloneFile = true;\n\
      {_CLOSING_BRCK}\n\
    {_CLOSING_BRCK}\n\
    if(pkgJson.packages[pkg].enums) {_OPEN_BRCK}\n\
      pkgJson.packages[pkg]?.enums.map(e => e.tag).map(e => files.push(e))\n\
      if(pkgJson.packages[pkg]?.enums.map(e => !e.tag).includes(true)) {_OPEN_BRCK}\n\
        standaloneFile = true;\n\
      {_CLOSING_BRCK}\n\
    {_CLOSING_BRCK}\n\
    if(files.length>0) {_OPEN_BRCK}\n\
      getUniqueStrings(files).map(f => protos.push(`${_OPEN_BRCK}pkg{_CLOSING_BRCK}/${_OPEN_BRCK}f{_CLOSING_BRCK}.proto`))\n\
      if(standaloneFile) {_OPEN_BRCK}\n\
        protos.push(`${_OPEN_BRCK}pkg{_CLOSING_BRCK}/${_OPEN_BRCK}pkgJson.packages[pkg].name{_CLOSING_BRCK}.proto`)  \n\
      {_CLOSING_BRCK}\n\
    {_CLOSING_BRCK} else {_OPEN_BRCK}\n\
      protos.push(`${_OPEN_BRCK}pkg{_CLOSING_BRCK}/${_OPEN_BRCK}pkgJson.packages[pkg].name{_CLOSING_BRCK}.proto`)\n\
    {_CLOSING_BRCK}\n\
  {_CLOSING_BRCK}\n\
{_CLOSING_BRCK}\n\
rimraf.sync(`${_OPEN_BRCK}MODEL_DIR{_CLOSING_BRCK}/*.ts`, {_OPEN_BRCK}\n\
  glob: {_OPEN_BRCK} ignore: `${_OPEN_BRCK}MODEL_DIR{_CLOSING_BRCK}/tsconfig.json` {_CLOSING_BRCK},\n\
{_CLOSING_BRCK});\n\n\
const protoConfig = [\n\
  `--plugin=${_OPEN_BRCK}PLUGIN_PATH{_CLOSING_BRCK}`,\n\n\
  // https://github.com/stephenh/ts-proto/blob/main/README.markdown\n\
  "--ts_proto_opt=outputServices=grpc-js,env=node,useOptionals=messages,exportCommonSymbols=false,esModuleInterop=true",\n\n\
  `--ts_proto_out=${_OPEN_BRCK}MODEL_DIR{_CLOSING_BRCK}`,\n\
  `--proto_path ${_OPEN_BRCK}PROTO_DIR{_CLOSING_BRCK} ${_OPEN_BRCK}protos.join(" "){_CLOSING_BRCK}`,\n\
];\n\n\
// https://github.com/stephenh/ts-proto#usage\n\
execSync(`${_OPEN_BRCK}PROTOC_PATH{_CLOSING_BRCK} ${_OPEN_BRCK}protoConfig.join(" "){_CLOSING_BRCK}`);\n\
console.log(`> Proto models created: ${_OPEN_BRCK}MODEL_DIR{_CLOSING_BRCK}`);'


def interceptors_js(version):
    return f"const unpack = (...args) => ({_OPEN_BRCK}\n\
	request: args[1], // Outgoing client call.request object\n\
	metadata: args[2], // Outgoing client call.metadata object\n\
	cb: args[3], // Client passed CallBack function\n\
	options: args[4], // Additional interceptors options\n\
	...args.slice(5) // for forward compatibility with future params\n\
{_CLOSING_BRCK})\n\n\
const defaultRetriesPolicy = {_OPEN_BRCK}\n\
	maxRetries:5,\n\
	backoff:true,\n\
	interval:100,\n\
	retryCodes: [1,2,3,4,5]\n\
{_CLOSING_BRCK}\n\n\
function _preMethodCallDecorator(fn) {_OPEN_BRCK}\n\
	return function (...args) {_OPEN_BRCK}\n\
	  // Do something before calling the method here\n\
	  // For example, you could log the method name and arguments\n\
	  const req = args[1];\n\
	  const md = args[2];\n\
	  if(md.get('sylk-version').length === 0) {_OPEN_BRCK}\n\
		  md.add('sylk-version','{version}')\n\
	  {_CLOSING_BRCK}\n\
	  // Call the method\n\
	  return fn.apply(this, args);\n\
	{_CLOSING_BRCK};\n\
{_CLOSING_BRCK}\n\n\
function _retry(next) {_OPEN_BRCK}\n\
	return function (...args) {_OPEN_BRCK}\n\
		const {_OPEN_BRCK} request, metadata, cb, options {_CLOSING_BRCK} = unpack(...args);\n\
        if (options) {_OPEN_BRCK}\n\
			if(options.retriesPolicy === undefined) {_OPEN_BRCK}\n\
				retriesPolicy = defaultRetriesPolicy\n\
			{_CLOSING_BRCK} else {_OPEN_BRCK}\n\
				retriesPolicy = options.retriesPolicy\n\
			{_CLOSING_BRCK}\n\
		{_CLOSING_BRCK} else {_OPEN_BRCK}\n\
			retriesPolicy = defaultRetriesPolicy\n\
		{_CLOSING_BRCK}\n\
        const retryCodes = retriesPolicy.retryCodes ? retriesPolicy.retryCodes : [];\n\
		const maxRetries = retriesPolicy.maxRetries ? retriesPolicy.maxRetries : 3;\n\n\
		const originalCB = cb;\n\
		let retryAttempt = 0;\n\
		let interval = retriesPolicy.interval ? retriesPolicy.interval : 100;\n\
		const retryCB = (err,res) => {_OPEN_BRCK}\n\
			if(err) {_OPEN_BRCK}\n\
                if (!retryCodes.includes(err.code)) {_OPEN_BRCK}\n\
					return originalCB ? originalCB(err,null) : err\n\
				{_CLOSING_BRCK} else {_OPEN_BRCK}\n\
                    retryAttempt += 1;\n\
                    const sylkMaxRetries = 'x-sylk-retries';\n\
                    let maxRetriesCount = metadata.get(sylkMaxRetries)\n\
                    maxRetriesCount.length>0 ? metadata.set(sylkMaxRetries,Number(maxRetriesCount[0])+1) : metadata.add(sylkMaxRetries,retryAttempt)\n\n\
                    if(retryAttempt >= maxRetries) {_OPEN_BRCK}\n\
                        args[3]=originalCB\n\
                    {_CLOSING_BRCK}\n\
                    setTimeout(() => {_OPEN_BRCK}\n\
                        request.todo_id = Number(request.todo_id) - 1\n\
                        next(...args)\n\n\
                    {_CLOSING_BRCK},interval * (retriesPolicy.backoff ? Math.pow(2, retryAttempt) : 1))\n\
                {_CLOSING_BRCK}\n\
			{_CLOSING_BRCK} else {_OPEN_BRCK}\n\
				return originalCB ? originalCB(null,res) : res\n\
			{_CLOSING_BRCK}\n\
		{_CLOSING_BRCK};\n\
		args[3] = retryCB\n\
		const result =  next(...args);\n\
		return result\n\
	{_CLOSING_BRCK};\n\
{_CLOSING_BRCK}\n\n\
module.exports = {_OPEN_BRCK}\n\
	clientMethodWrapper : _preMethodCallDecorator,\n\
    clientRetries : _retry\n\
{_CLOSING_BRCK}"


def js_package_json(prj_name):
    return '{\n\
\t"name": "REPLACEME",\n\
\t"version": "1.0.0",\n\
\t"description": "",\n\
\t"main": "index.js",\n\
\t"scripts": {\n\
\t"test": "echo \\"Error: no test specified\\" && exit 1"\n\
\t},\n\
\t"keywords": [],\n\
\t"author": "",\n\
\t"license": "ISC",\n\
\t"dependencies": {\n\
\t"@grpc/grpc-js": "^1.8.14"\n\
\t}\n\
}'.replace(
        "REPLACEME", prj_name
    )

def package_json(prj_name: str,code_base_path: str):
 return f'{_OPEN_BRCK}\n\
    "name": "{prj_name}",\n\
    "version": "1.0.0",\n\
    "description": "This project has been generated thanks to ```Sylk.build``` CLI. For start using it please run  ```sylk run --build```  and see the magic in action. For more information please visit https://docs.sylk.build",\n\
    "main": "bin/proto.js",\n\
    "scripts": {_OPEN_BRCK}\n\
        "test": "echo \\"Error: no test specified\\" && exit 1",\n\
        "lint": "eslint --ext .ts .",\n\
        "build": "node bin/proto && rimraf {code_base_path}/clients/typescript/protos && rimraf {code_base_path}/clients/typescript/index.* && rimraf {code_base_path}/server && tsc -b",\n\
        "build:webpack": "bash bin/webpack.sh",\n\
        "start": "node clients/typescript/server",\n\
        "client": "node clients/typescript/client",\n\
        "health": "node clients/typescript/health"\n\
    {_CLOSING_BRCK},\n\
    "author": "",\n\
    "license": "ISC",\n\
    "dependencies": {_OPEN_BRCK}\n\
        "@grpc/grpc-js": "^1.6.12",\n\
        "rxjs": "^7.5.6"\n\
    {_CLOSING_BRCK},\n\
    "devDependencies": {_OPEN_BRCK}\n\
        "@types/node": "^18.7.14",\n\
        "@typescript-eslint/eslint-plugin": "^5.36.1",\n\
        "@typescript-eslint/parser": "^5.36.1",\n\
        "eslint": "^8.23.0",\n\
        "eslint-config-airbnb-base": "^15.0.0",\n\
        "eslint-config-airbnb-typescript": "^17.0.0",\n\
        "eslint-plugin-import": "^2.26.0",\n\
        "eslint-plugin-sonarjs": "^0.15.0",\n\
        "grpc-tools": "^1.11.2",\n\
        "rimraf": "^3.0.2",\n\
        "ts-proto": "^1.123.1",\n\
        "typescript": "^4.8.2",\n\
        "ts-node": "^10.9.1"\n\
    {_CLOSING_BRCK}\n\
{_CLOSING_BRCK}'

package_json_webpack = '{\n\
  "name": "REPLACEME",\n\
  "version": "1.0.0",\n\
  "description": "This project has been generated thanks to [`sylk.build`](https://sylk.build/) CLI. For start using it please run  ```sylk build && sylk run```  and see the magic in action. For more information please visit https://docs.sylk.build",\n\
  "scripts": {\n\
    "build": "echo \\"Error: no build specified\\" && exit 1",\n\
    "test": "echo \\"Error: no test specified\\" && exit 1",\n\
    "dev": "echo \\"Error: no dev specified\\" && exit 1",\n\
    "start": "echo \\"Error: no start specified\\" && exit 1"\n\
  },\n\
  "author": "",\n\
  "license": "Apache-2.0",\n\
  "devDependencies": {\n\
    "@types/google-protobuf": "^3.15.6"\n\
  },\n\
  "engines": {\n\
    "node": ">=14"\n\
  },\n\
  "dependencies": {\n\
    "@grpc/grpc-js": "~1.1.8",\n\
    "@grpc/proto-loader": "~0.5.4",\n\
    "async": "~3.2.3",\n\
    "google-protobuf": "~3.14.0",\n\
    "grpc-tools": "^1.11.2",\n\
    "grpc-web": "~1.4.2",\n\
    "lodash": "~4.17.0",\n\
    "webpack": "~4.43.0",\n\
    "webpack-cli": "~3.3.11"\n\
  }\n\
}'

utils_errors_ts = "import { Metadata, ServiceError as grpcServiceError, status } from '@grpc/grpc-js';\n\n\
/**\n\
 * https://grpc.io/grpc/node/grpc.html#~ServiceError__anchor\n\
 */\n\
export class ServiceError extends Error implements Partial<grpcServiceError> {\n\
	public override name: string = 'ServiceError';\n\n\
	constructor(\n\
		public code: status,\n\
		public override message: string,\n\
		public details?: string,\n\
		public metadata?: Metadata,\n\
	) {\n\
		super(message);\n\
	}\n\
}"

utils_interfaces = "// Insert here more interfaces to service will be able to speak with\n\
interface Api<T> {\n\
	[method: string]: T;\n\
}\n\n\
export type ApiType<T> = Api<T> & {\n\
\n\
}"

def main_ts_config(code_base_path: str):
    code_base_path = f"{code_base_path}/" if code_base_path is not None and code_base_path != '' else ''
    return  f'{_OPEN_BRCK}\n\
    "compilerOptions": {_OPEN_BRCK}\n\
        "baseUrl": ".",\n\
        "paths": {_OPEN_BRCK}{_CLOSING_BRCK},\n\
        "target": "ES2019",\n\
        "outDir": "dist",\n\
        "module": "commonjs",\n\
        "moduleResolution": "node",\n\
        "incremental": true,\n\
        "declaration": true,\n\
        "newLine": "lf",\n\
        "strict": true,\n\
        "allowUnreachableCode": false,\n\
        "allowUnusedLabels": false,\n\
        "noFallthroughCasesInSwitch": true,\n\
        "noImplicitOverride": true,\n\
        "noImplicitReturns": true,\n\
        "noPropertyAccessFromIndexSignature": true,\n\
        "noUnusedLocals": false,\n\
        "noUnusedParameters": false,\n\
        "removeComments": false,\n\
        "sourceMap": true,\n\
        "forceConsistentCasingInFileNames": true,\n\
        "esModuleInterop": true,\n\
        "skipLibCheck": true\n\
    {_CLOSING_BRCK},\n\
    "include": [\n\
        "{code_base_path}services/**/*",\n\
        "{code_base_path}services/*.ts",\n\
        "{code_base_path}*.ts"\n\
    ],\n\
    "exclude": [\n\
        "node_modules",\n\
        "{code_base_path}services/protos"\n\
    ],\n\
    "references": [\n\
        {_OPEN_BRCK}\n\
            "path": "{code_base_path}services/protos"\n\
        {_CLOSING_BRCK}\n\
    ]\n\
{_CLOSING_BRCK}'

clients_ts_configs = '{\n\
    "extends": "../tsconfig.json",\n\
    "compilerOptions": {\n\
        "composite": true,\n\
        "outDir": "../clients/typescript",\n\
        "noImplicitReturns": false\n\
    },\n\
    "include": [\n\
        "client.ts","protos/**/*","protos/*.ts"\n\
    ],\n\
    "exclude": [\n\
        "node_modules"\n\
    ]\n\
}'


def protos_ts_config(domain, code_base_path: str):
    _base_tmp_path = ''
    if code_base_path is not None and code_base_path != '':
        for p in code_base_path.split('/'):
            _base_tmp_path += '../'
    code_base_path = _base_tmp_path if code_base_path is None or code_base_path != '' else ''
    return f'{_OPEN_BRCK}\n\
    "extends": "{_base_tmp_path}../../tsconfig.json",\n\
    "compilerOptions": {_OPEN_BRCK}\n\
        "composite": true,\n\
        "outDir": "{_base_tmp_path}../../dist/services/protos",\n\
        "noImplicitReturns": false\n\
    {_CLOSING_BRCK},\n\
    "include": [\n\
        "{domain}/**/*","google/**/*"\n\
    ],\n\
    "exclude": [\n\
        "node_modules"\n\
    ]\n\
{_CLOSING_BRCK}'


main_ts_config_client_only = '{\n\
    "compilerOptions": {\n\
        "baseUrl": ".",\n\
        "paths": {},\n\
        "target": "ES2019",\n\
        "outDir": "clients/typescript",\n\
        "module": "commonjs",\n\
        "moduleResolution": "node",\n\
        "incremental": true,\n\
        "declaration": true,\n\
        "newLine": "lf",\n\
        "strict": true,\n\
        "allowUnreachableCode": false,\n\
        "allowUnusedLabels": false,\n\
        "noFallthroughCasesInSwitch": true,\n\
        "noImplicitOverride": true,\n\
        "noImplicitReturns": true,\n\
        "noPropertyAccessFromIndexSignature": true,\n\
        "noUnusedLocals": false,\n\
        "noUnusedParameters": false,\n\
        "removeComments": false,\n\
        "sourceMap": true,\n\
        "forceConsistentCasingInFileNames": true,\n\
        "esModuleInterop": true,\n\
        "skipLibCheck": true\n\
    },\n\
    "include": [\n\
        "services/**/*",\n\
        "services/*.ts",\n\
    ],\n\
    "exclude": [\n\
        "node_modules",\n\
        "services/protos"\n\
    ],\n\
    "references": [\n\
        {\n\
            "path": "services/protos"\n\
        }\n\
    ]\n\
}'


def protos_ts_config_client_only(domain):
    return f'{_OPEN_BRCK}\n\
    "extends": "../../tsconfig.json",\n\
    "compilerOptions": {_OPEN_BRCK}\n\
        "composite": true,\n\
        "outDir": "../../clients/typescript/protos",\n\
        "noImplicitReturns": false\n\
    {_CLOSING_BRCK},\n\
    "include": [\n\
        "{domain}/**/*","google/**/*"\n\
    ],\n\
    "exclude": [\n\
        "node_modules"\n\
    ]\n\
{_CLOSING_BRCK}'


def bash_run_server_script_go(code_base_path):
    return '#!/bin/bash\n\n\
if [[ $1 == "debug" ]]\n\
then\n\
\techo "Debug mode: $1"\n\
\tGRPC_VERBOSITY=DEBUG GRPC_TRACE=all go run {0}\n\
elif [[ $1 == "info" ]]\n\
then\n\
\techo "Info Mode: $1"\n\
\tGRPC_VERBOSITY=INFO GRPC_TRACE=all go run {0}\n\
else\n\
\tgo run {0}\n\
fi'.format(file_system.join_path('.',code_base_path,'server','server.go'))

logger_js = ""

utils_go = 'package utils\n\n\
import (\n\
	"log"\n\
)\n\n\
var (\n\
	WarningLogger *log.Logger\n\
	DebugLogger   *log.Logger\n\
	InfoLogger    *log.Logger\n\
	ErrorLogger   *log.Logger\n\
)\n\n\
func init() {\n\
	InfoLogger = log.New(log.Writer(), "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)\n\
	DebugLogger = log.New(log.Writer(), "DEBUG: ", log.Ldate|log.Ltime|log.Lshortfile)\n\
	WarningLogger = log.New(log.Writer(), "WARNING: ", log.Ldate|log.Ltime|log.Lshortfile)\n\
	ErrorLogger = log.New(log.Writer(), "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)\n\
}'

sylk_go_utils_channel = 'package buildChannel\n\n\
import (\n\
	"context"\n\
	"crypto/tls"\n\
	"crypto/x509"\n\
	"fmt"\n\
	"log"\n\n\
	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"\n\
	"google.golang.org/grpc"\n\
	"google.golang.org/grpc/credentials"\n\
	"google.golang.org/grpc/credentials/insecure"\n\
	"google.golang.org/grpc/keepalive"\n\
)\n\n\
// GrpcClientConnBuilder is a builder to create GRPC connection to the GRPC Server\n\
type GrpcClientConnBuilder interface {\n\
	WithContext(ctx context.Context)\n\
	WithOptions(opts ...grpc.DialOption)\n\
	WithInsecure()\n\
	WithUnaryInterceptors(interceptors []grpc.UnaryClientInterceptor)\n\
	WithStreamInterceptors(interceptors []grpc.StreamClientInterceptor)\n\
	WithKeepAliveParams(params keepalive.ClientParameters)\n\
	GetConn(addr string) (*grpc.ClientConn, error)\n\
}\n\n\
// GRPC client builder\n\
type GrpcConnBuilder struct {\n\
	options              []grpc.DialOption\n\
	enabledReflection    bool\n\
	shutdownHook         func()\n\
	enabledHealthCheck   bool\n\
	ctx                  context.Context\n\
	transportCredentials credentials.TransportCredentials\n\
	err                  error\n\
}\n\n\
// WithContext set the context to be used in the dial\n\
func (b *GrpcConnBuilder) WithContext(ctx context.Context) {\n\
	b.ctx = ctx\n\
}\n\n\
// WithOptions set dial options\n\
func (b *GrpcConnBuilder) WithOptions(opts ...grpc.DialOption) {\n\
	b.options = append(b.options, opts...)\n\
}\n\n\
// WithInsecure set the connection as insecure\n\
func (b *GrpcConnBuilder) WithInsecure() {\n\
	b.options = append(b.options, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\
}\n\n\
// WithBlock the dialing blocks until the  underlying connection is up.\n\
// Without this, Dial returns immediately and connecting the server happens in background.\n\
func (b *GrpcConnBuilder) WithBlock() {\n\
	b.options = append(b.options, grpc.WithBlock())\n\
}\n\n\
// WithKeepAliveParams set the keep alive params\n\
// ClientParameters is used to set keepalive parameters on the client-side.\n\
// These configure how the client will actively probe to notice when a\n\
// connection is broken and send pings so intermediaries will be aware of the\n\
// liveness of the connection. Make sure these parameters are set in\n\
// coordination with the keepalive policy on the server, as incompatible\n\
// settings can result in closing of connection.\n\
func (b *GrpcConnBuilder) WithKeepAliveParams(params keepalive.ClientParameters) {\n\
	keepAlive := grpc.WithKeepaliveParams(params)\n\
	b.options = append(b.options, keepAlive)\n\
}\n\
// WithUnaryInterceptors set a list of interceptors to the Grpc client for unary connection\n\
// By default, gRPC doesn\'t allow one to have more than one interceptor either on the client nor on the server side.\n\
// By using `grpc_middleware` we are able to provides convenient method to add a list of interceptors\n\
func (b *GrpcConnBuilder) WithUnaryInterceptors(interceptors []grpc.UnaryClientInterceptor) {\n\
	b.options = append(b.options, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(interceptors...)))\n\
}\n\n\
// WithUnaryInterceptors set a list of interceptors to the Grpc client for stream connection\n\
// By default, gRPC doesn\'t allow one to have more than one interceptor either on the client nor on the server side.\n\
// By using `grpc_middleware` we are able to provides convenient method to add a list of interceptors\n\
func (b *GrpcConnBuilder) WithStreamInterceptors(interceptors []grpc.StreamClientInterceptor) {\n\
	b.options = append(b.options, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(interceptors...)))\n\
}\n\n\
// ClientTransportCredentials builds transport credentials for a gRPC client using the given properties.\n\
func (b *GrpcConnBuilder) WithClientTransportCredentials(insecureSkipVerify bool, certPool *x509.CertPool) {\n\
	var tlsConf tls.Config\n\n\
	if insecureSkipVerify {\n\
		tlsConf.InsecureSkipVerify = true\n\
		b.transportCredentials = credentials.NewTLS(&tlsConf)\n\
		return\n\
	}\n\n\
	tlsConf.RootCAs = certPool\n\
	b.transportCredentials = credentials.NewTLS(&tlsConf)\n\
}\n\n\
// GetConn returns the client connection to the server\n\
func (b *GrpcConnBuilder) GetConn(addr string) (*grpc.ClientConn, error) {\n\
	if addr == "" {\n\
		return nil, fmt.Errorf("target connection parameter missing. address = %s", addr)\n\
	}\n\
	log.Printf("Target to connect = %s", addr)\n\
	cc, err := grpc.DialContext(b.getContext(), addr, b.options...)\n\n\
	if err != nil {\n\
		return nil, fmt.Errorf("unable to connect to client. address = %s. error = %+v", addr, err)\n\
	}\n\
	return cc, nil\n\
}\n\n\
// GetTlsConn returns client connection to the server\n\
func (b *GrpcConnBuilder) GetTlsConn(addr string) (*grpc.ClientConn, error) {\n\
	b.options = append(b.options, grpc.WithTransportCredentials(b.transportCredentials))\n\
	cc, err := grpc.DialContext(\n\
		b.getContext(),\n\
		addr,\n\
		b.options...,\n\
	)\n\
	if err != nil {\n\
		return nil, fmt.Errorf("failed to get tls conn. Unable to connect to client. address = %s: %w", addr, err)\n\
	}\n\
	return cc, nil\n\
}\n\n\
func (b *GrpcConnBuilder) getContext() context.Context {\n\
	ctx := b.ctx\n\
	if ctx == nil {\n\
		ctx = context.Background()\n\
	}\n\
	return ctx\n\
}'
