import re
from num2words import num2words
import argparse

from pathlib import Path


def number_to_word(n, lang="en") -> str:
    """
    Converts a number to a word

    """
    if type(n) == float:
        # I thought this was extra funny
        whole = num2words(int(n), lang=lang).upper()
        frac = ""
        # Spell out each digit in the fraction
        for digit in str(n).split(".")[1]:
            frac += num2words(int(digit), lang=lang).upper() + "_"
        frac = frac[:-1]  # Remove the last underscore
        return f"{whole}_POINT_{frac}"
    else:
        # I see the irony in making a readability improver with this next line
        return num2words(n, lang=lang).upper().replace("-", "_").replace(" ", "_")


class Mappings:
    AUTOCODER_HEADER = "// This file was generated by readability_improver. Do not edit this file directly.\n\n"

    def __init__(self):
        self.imappings = {}
        self.fmappings = {}

    def add_mapping(self, key, value):
        if type(key) == int:
            self.imappings[key] = value
        else:
            self.fmappings[key] = value

    def to_pound_defines(self) -> str:
        return self._create_pound_defines(self.imappings) + self._create_pound_defines(
            self.fmappings
        )

    def to_constants_file(
        self, filename: Path = Path("constants.h"), mode: str = "w"
    ) -> str:
        clean_header_name = f"__{filename.name.replace('.', '_').upper()}__"
        ifdef_guard_top = (
            f"#ifndef {clean_header_name}\n#define {clean_header_name}\n\n"
        )
        ifdef_guard_bottom = f"\n#endif // {clean_header_name}"

        with open(filename, mode) as file:
            file.write(ifdef_guard_top)
            file.write(self.AUTOCODER_HEADER)
            file.write(self.to_pound_defines())
            file.write(ifdef_guard_bottom)
            file.write("\n") # Always end with a newline

    @classmethod
    def from_file(cls: "Mappings", filepath: str) -> "Mappings":
        numbers = extract_numbers(filepath)
        mappings = cls()
        for n in numbers:
            if type(n) == int:
                if n not in mappings.imappings:
                    mappings.imappings[n] = number_to_word(n)
            else:
                if n not in mappings.fmappings:
                    mappings.fmappings[n] = number_to_word(n)
        return mappings

    @staticmethod
    def _create_pound_defines(mappings: "dict[int|float, str]") -> str:
        """Creates pound defines for numbers

        Args:
            mappings (dict[int|float, str]): Mappings of numbers to words

        Returns:
            str: Pound defines
        """
        defines = ""
        for k, v in mappings.items():
            defines += f"#define {v} ({k})\n"
        return defines


def extract_numbers(f: str) -> "list[int|float]":
    """Extracts numbers from a file

    Args:
        f (str): File to extract numbers from

    Returns:
        list[int|float]: List of numbers
    """
    with open(f, "r") as file:
        content = file.read()
        return [
            int(x) if x.isdigit() else float(x)
            for x in re.findall(r"\d+\.?\d*", content)
        ]


class UnreadableFile:
    def __init__(self, path: Path) -> None:
        self.path = path
        self.mappings = Mappings.from_file(path)

    def _replace_numbers(self, content: str, fmappings: dict, imappings: dict) -> str:
        """Replaces numbers in a file with words

        Args:
            f (str): File to replace numbers in
            fmappings (dict): Float mappings
            imappings (dict): Integer mappings
        """
        for k, v in fmappings.items():
            # if there's a f following the number, remove the f
            content = content.replace(str(k) + "f", v)
            content = content.replace(str(k), v)
        for k, v in imappings.items():
            content = content.replace(str(k), v)
        return content

    def make_readable(self, inplace=False, constants_file=Path("constants.h")) -> None:
        """Makes a file readable

        Args:
            inplace (bool, optional): Whether to convert the file inplace. Defaults to False.
            constants_file (str, optional): File to dump constants to. Defaults to "constants.h".
        """
        with open(self.path, "r") as file:
            content = file.read()
            replacement = self._replace_numbers(
                content, self.mappings.fmappings, self.mappings.imappings
            )

            if inplace:
                newfilename = self.path
            else:
                newfilename = (
                    file.name.split(".")[0] + "_fixed." + file.name.split(".")[1]
                )

            with open(newfilename, "w") as file:
                file.write(f'#include "{constants_file.name}"\n\n')
                file.write(replacement)

            if constants_file.exists():
                mode = "a"
            else:
                mode = "w"

            self.mappings.to_constants_file(constants_file, mode)


def main():
    """Main function"""

    parser = argparse.ArgumentParser(description="Makes your code 1000% more readable")
    parser.add_argument("path", type=Path, help="File or directory to convert")
    parser.add_argument(
        "constants",
        type=Path,
        help="Filename to dump constants to",
        nargs="?",
        default="constants.h",
    )
    parser.add_argument(
        "-i", "--inplace", action="store_true", help="Convert file inplace"
    )
    args = parser.parse_args()

    if args.path.is_dir():
        raise NotImplementedError("I couldn't be bothered rn")

    if args.path.suffix != ".c" and args.path.suffix != ".cpp":
        raise NotImplementedError("I couldn't be bothered rn")

    bad_file = UnreadableFile(args.path)
    bad_file.make_readable(inplace=args.inplace, constants_file=args.constants)


if __name__ == "__main__":
    main()
