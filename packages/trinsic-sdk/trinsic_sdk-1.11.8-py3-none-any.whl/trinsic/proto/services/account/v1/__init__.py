# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: services/account/v1/account.proto
# plugin: python-betterproto
import warnings
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ConfirmationMethod(betterproto.Enum):
    """Confirmation method type for two-factor workflows"""

    None_ = 0
    """No confirmation required"""

    Email = 1
    """Email confirmation required"""

    Sms = 2
    """SMS confirmation required"""

    ConnectedDevice = 3
    """Confirmation from a connected device is required"""

    Other = 10
    """Third-party method of confirmation is required"""


@dataclass(eq=False, repr=False)
class AccountDetails(betterproto.Message):
    """Account registration details"""

    name: str = betterproto.string_field(1)
    """Account name"""

    email: str = betterproto.string_field(2)
    """Email address of account."""

    sms: str = betterproto.string_field(3)
    """SMS number including country code"""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("email"):
            warnings.warn("AccountDetails.email is deprecated", DeprecationWarning)
        if self.is_set("sms"):
            warnings.warn("AccountDetails.sms is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class TokenProtection(betterproto.Message):
    """Token protection info"""

    enabled: bool = betterproto.bool_field(1)
    """
    Indicates if token is protected using a PIN, security code, HSM secret,
    etc.
    """

    method: "ConfirmationMethod" = betterproto.enum_field(2)
    """The method used to protect the token"""


@dataclass(eq=False, repr=False)
class AccountProfile(betterproto.Message):
    """
    Device profile containing sensitive authentication data. This information
    should be stored securely
    """

    profile_type: str = betterproto.string_field(1)
    """
    The type of profile, used to differentiate between protocol schemes or
    versions
    """

    auth_data: bytes = betterproto.bytes_field(2)
    """Auth data containg information about the current device access"""

    auth_token: bytes = betterproto.bytes_field(3)
    """Secure token issued by server used to generate zero-knowledge proofs"""

    protection: "TokenProtection" = betterproto.message_field(4)
    """
    Token security information about the token. If token protection is enabled,
    implementations must supply protection secret before using the token for
    authentication.
    """


@dataclass(eq=False, repr=False)
class AccountInfoRequest(betterproto.Message):
    """Request for information about the account used to make the request"""

    pass


@dataclass(eq=False, repr=False)
class AccountInfoResponse(betterproto.Message):
    """Information about the account used to make the request"""

    details: "AccountDetails" = betterproto.message_field(1)
    """The account details associated with the calling request context"""

    wallet_id: str = betterproto.string_field(3)
    """The wallet ID associated with this account"""

    device_id: str = betterproto.string_field(4)
    """The device ID associated with this account session"""

    ecosystem_id: str = betterproto.string_field(5)
    """The ecosystem ID within which this account resides"""

    public_did: str = betterproto.string_field(6)
    """
    The public DID associated with this account. This DID is used as the
    `issuer` when signing verifiable credentials
    """

    auth_tokens: List["WalletAuthToken"] = betterproto.message_field(8)
    """
    List of active authentication tokens for this wallet. This list does not
    contain the issued token, only metadata such as ID, description, and
    creation date.
    """


@dataclass(eq=False, repr=False)
class LoginRequest(betterproto.Message):
    """Request to begin login flow"""

    email: str = betterproto.string_field(1)
    """
    Email address of account. If unspecified, an anonymous account will be
    created.
    """

    ecosystem_id: str = betterproto.string_field(3)
    """ID of Ecosystem to sign into."""


@dataclass(eq=False, repr=False)
class LoginResponse(betterproto.Message):
    """Response to `LoginRequest`"""

    challenge: bytes = betterproto.bytes_field(1, group="response")
    """
    Random byte sequence unique to this login request. If present, two-factor
    confirmation of login is required. Must be sent back, unaltered, in
    `LoginConfirm`.
    """

    profile: "AccountProfile" = betterproto.message_field(2, group="response")
    """
    Account profile response. If present, no confirmation of login is required.
    """


@dataclass(eq=False, repr=False)
class LoginConfirmRequest(betterproto.Message):
    """Request to finalize login flow"""

    challenge: bytes = betterproto.bytes_field(1)
    """Challenge received from `Login`"""

    confirmation_code_hashed: bytes = betterproto.bytes_field(2)
    """
    Two-factor confirmation code sent to account email or phone, hashed using
    Blake3. Our SDKs will handle this hashing process for you.
    """


@dataclass(eq=False, repr=False)
class LoginConfirmResponse(betterproto.Message):
    """Response to `LoginConfirmRequest`"""

    profile: "AccountProfile" = betterproto.message_field(1)
    """
    Profile response; must be unprotected using unhashed confirmation code. Our
    SDKs will handle this process for you, and return to you an authentication
    token string.
    """


@dataclass(eq=False, repr=False)
class WalletAuthToken(betterproto.Message):
    """Information about authentication tokens for a wallet"""

    id: str = betterproto.string_field(1)
    """
    Unique identifier for the token. This field will match the `DeviceId` in
    the WalletAuthData
    """

    description: Optional[str] = betterproto.string_field(
        2, optional=True, group="_description"
    )
    """Device name/description"""

    date_created: str = betterproto.string_field(3)
    """Date when the token was created in ISO 8601 format"""


class AccountStub(betterproto.ServiceStub):
    async def login(
        self,
        login_request: "LoginRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "LoginResponse":
        return await self._unary_unary(
            "/services.account.v1.Account/Login",
            login_request,
            LoginResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def login_confirm(
        self,
        login_confirm_request: "LoginConfirmRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "LoginConfirmResponse":
        return await self._unary_unary(
            "/services.account.v1.Account/LoginConfirm",
            login_confirm_request,
            LoginConfirmResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def info(
        self,
        account_info_request: "AccountInfoRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "AccountInfoResponse":
        return await self._unary_unary(
            "/services.account.v1.Account/Info",
            account_info_request,
            AccountInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class AccountBase(ServiceBase):
    async def login(self, login_request: "LoginRequest") -> "LoginResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def login_confirm(
        self, login_confirm_request: "LoginConfirmRequest"
    ) -> "LoginConfirmResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def info(
        self, account_info_request: "AccountInfoRequest"
    ) -> "AccountInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_login(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.login(request)
        await stream.send_message(response)

    async def __rpc_login_confirm(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.login_confirm(request)
        await stream.send_message(response)

    async def __rpc_info(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.info(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/services.account.v1.Account/Login": grpclib.const.Handler(
                self.__rpc_login,
                grpclib.const.Cardinality.UNARY_UNARY,
                LoginRequest,
                LoginResponse,
            ),
            "/services.account.v1.Account/LoginConfirm": grpclib.const.Handler(
                self.__rpc_login_confirm,
                grpclib.const.Cardinality.UNARY_UNARY,
                LoginConfirmRequest,
                LoginConfirmResponse,
            ),
            "/services.account.v1.Account/Info": grpclib.const.Handler(
                self.__rpc_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                AccountInfoRequest,
                AccountInfoResponse,
            ),
        }
