# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .audiences_sub_object import AudiencesSubObject
from .post_campaign_response_data_attributes_send_options import PostCampaignResponseDataAttributesSendOptions
from .post_campaign_response_data_attributes_tracking_options import PostCampaignResponseDataAttributesTrackingOptions
from .send_strategy_sub_object import SendStrategySubObject


class PostCampaignResponseDataAttributes(pydantic.BaseModel):
    name: str = pydantic.Field(description="The campaign name")
    status: str = pydantic.Field(description="The current status of the campaign")
    archived: bool = pydantic.Field(description="Whether the campaign has been archived or not")
    audiences: AudiencesSubObject = pydantic.Field(
        description="The audiences to be included and/or excluded from the campaign"
    )
    send_options: PostCampaignResponseDataAttributesSendOptions = pydantic.Field(
        description="Options to use when sending a campaign"
    )
    tracking_options: PostCampaignResponseDataAttributesTrackingOptions = pydantic.Field(
        description="The tracking options associated with the campaign"
    )
    send_strategy: SendStrategySubObject = pydantic.Field(description="The send strategy the campaign will send with")
    created_at: dt.datetime = pydantic.Field(description="The datetime when the campaign was created")
    scheduled_at: dt.datetime = pydantic.Field(
        description="The datetime when the campaign was scheduled for future sending"
    )
    updated_at: dt.datetime = pydantic.Field(
        description="The datetime when the campaign was last updated by a user or the system"
    )
    send_time: dt.datetime = pydantic.Field(
        description="The datetime when the campaign will be / was sent or None if not yet scheduled by a send_job."
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
