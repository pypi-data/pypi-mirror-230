# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.get_template_request_fields_template_item import GetTemplateRequestFieldsTemplateItem
from ...types.get_template_response import GetTemplateResponse
from ...types.get_template_response_collection import GetTemplateResponseCollection
from ...types.get_templates_request_fields_template_item import GetTemplatesRequestFieldsTemplateItem
from ...types.get_templates_request_sort import GetTemplatesRequestSort
from ...types.patch_template_response import PatchTemplateResponse
from ...types.post_template_response import PostTemplateResponse
from ...types.template_clone_query_resource_object import TemplateCloneQueryResourceObject
from ...types.template_create_query_resource_object import TemplateCreateQueryResourceObject
from ...types.template_render_query_resource_object import TemplateRenderQueryResourceObject
from ...types.template_update_query_resource_object import TemplateUpdateQueryResourceObject

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TemplatesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_templates(
        self,
        *,
        fields_template: typing.Union[
            typing.Optional[GetTemplatesRequestFieldsTemplateItem], typing.List[GetTemplatesRequestFieldsTemplateItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTemplatesRequestSort] = None,
    ) -> GetTemplateResponseCollection:
        """
        Get all templates in an account.

        Filter to request a subset of all templates. Templates can be sorted by the following fields, in ascending and descending order: `id`, `name`, `created`, `updated`

        Returns a maximum of 10 results per page.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - fields_template: typing.Union[typing.Optional[GetTemplatesRequestFieldsTemplateItem], typing.List[GetTemplatesRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`id`: `any`, `equals`<br>`name`: `any`, `equals`<br>`created`: `equals`, `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`updated`: `equals`, `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTemplatesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/templates"),
            params=remove_none_from_dict(
                {"fields[template]": fields_template, "filter": filter, "page[cursor]": page_cursor, "sort": sort}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_template(self, *, data: TemplateCreateQueryResourceObject) -> PostTemplateResponse:
        """
        Create a new custom HTML template.

        If there are 1,000 or more templates in an account, creation will fail as there is a limit of 1,000 templates
        that can be created via the API.

        Request specific fields using [sparse fieldsets](https://developers.klaviyo.com/en/reference/api_overview#sparse-fieldsets).<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - data: TemplateCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/templates"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_template(
        self,
        id: str,
        *,
        fields_template: typing.Union[
            typing.Optional[GetTemplateRequestFieldsTemplateItem], typing.List[GetTemplateRequestFieldsTemplateItem]
        ],
    ) -> GetTemplateResponse:
        """
        Get a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - id: str. The ID of template

            - fields_template: typing.Union[typing.Optional[GetTemplateRequestFieldsTemplateItem], typing.List[GetTemplateRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            params=remove_none_from_dict({"fields[template]": fields_template}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_template(self, id: str, *, data: TemplateUpdateQueryResourceObject) -> PatchTemplateResponse:
        """
        Update a template with the given template ID. Does not currently update drag & drop templates.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - id: str. The ID of template

            - data: TemplateUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_template(self, id: str) -> None:
        """
        Delete a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - id: str. The ID of template
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_template_render(self, *, data: TemplateRenderQueryResourceObject) -> PostTemplateResponse:
        """
        Render a template with the given template ID and context attribute. Returns the HTML and plain text versions of the email template.

        **Request body parameters** (nested under `attributes`):

        * `return_fields`: Request specific fields using [sparse fieldsets](https://developers.klaviyo.com/en/reference/api_overview#sparse-fieldsets).

        * `context`: This is the context your email template will be rendered with. You must pass in a `context` object as a JSON object.

        Email templates are rendered with contexts in a similar manner to Django templates. Nested template variables can be referenced via dot notation. Template variables without corresponding `context` values are treated as `FALSE` and output nothing.

        Ex. `{ "name" : "George Washington", "state" : "VA" }`<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - data: TemplateRenderQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/template-render"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_template_clone(self, *, data: TemplateCloneQueryResourceObject) -> PostTemplateResponse:
        """
        Create a clone of a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - data: TemplateCloneQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/template-clone"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTemplatesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_templates(
        self,
        *,
        fields_template: typing.Union[
            typing.Optional[GetTemplatesRequestFieldsTemplateItem], typing.List[GetTemplatesRequestFieldsTemplateItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTemplatesRequestSort] = None,
    ) -> GetTemplateResponseCollection:
        """
        Get all templates in an account.

        Filter to request a subset of all templates. Templates can be sorted by the following fields, in ascending and descending order: `id`, `name`, `created`, `updated`

        Returns a maximum of 10 results per page.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - fields_template: typing.Union[typing.Optional[GetTemplatesRequestFieldsTemplateItem], typing.List[GetTemplatesRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`id`: `any`, `equals`<br>`name`: `any`, `equals`<br>`created`: `equals`, `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`updated`: `equals`, `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTemplatesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/templates"),
            params=remove_none_from_dict(
                {"fields[template]": fields_template, "filter": filter, "page[cursor]": page_cursor, "sort": sort}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_template(self, *, data: TemplateCreateQueryResourceObject) -> PostTemplateResponse:
        """
        Create a new custom HTML template.

        If there are 1,000 or more templates in an account, creation will fail as there is a limit of 1,000 templates
        that can be created via the API.

        Request specific fields using [sparse fieldsets](https://developers.klaviyo.com/en/reference/api_overview#sparse-fieldsets).<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - data: TemplateCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/templates"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_template(
        self,
        id: str,
        *,
        fields_template: typing.Union[
            typing.Optional[GetTemplateRequestFieldsTemplateItem], typing.List[GetTemplateRequestFieldsTemplateItem]
        ],
    ) -> GetTemplateResponse:
        """
        Get a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - id: str. The ID of template

            - fields_template: typing.Union[typing.Optional[GetTemplateRequestFieldsTemplateItem], typing.List[GetTemplateRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            params=remove_none_from_dict({"fields[template]": fields_template}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_template(self, id: str, *, data: TemplateUpdateQueryResourceObject) -> PatchTemplateResponse:
        """
        Update a template with the given template ID. Does not currently update drag & drop templates.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - id: str. The ID of template

            - data: TemplateUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_template(self, id: str) -> None:
        """
        Delete a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - id: str. The ID of template
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/templates/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_template_render(self, *, data: TemplateRenderQueryResourceObject) -> PostTemplateResponse:
        """
        Render a template with the given template ID and context attribute. Returns the HTML and plain text versions of the email template.

        **Request body parameters** (nested under `attributes`):

        * `return_fields`: Request specific fields using [sparse fieldsets](https://developers.klaviyo.com/en/reference/api_overview#sparse-fieldsets).

        * `context`: This is the context your email template will be rendered with. You must pass in a `context` object as a JSON object.

        Email templates are rendered with contexts in a similar manner to Django templates. Nested template variables can be referenced via dot notation. Template variables without corresponding `context` values are treated as `FALSE` and output nothing.

        Ex. `{ "name" : "George Washington", "state" : "VA" }`<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `templates:read`

        Parameters:
            - data: TemplateRenderQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/template-render"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_template_clone(self, *, data: TemplateCloneQueryResourceObject) -> PostTemplateResponse:
        """
        Create a clone of a template with the given template ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `template:write`

        Parameters:
            - data: TemplateCloneQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/template-clone"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
