# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.campaign_clone_query_resource_object import CampaignCloneQueryResourceObject
from ...types.campaign_create_query_resource_object import CampaignCreateQueryResourceObject
from ...types.campaign_message_assign_template_query_resource_object import (
    CampaignMessageAssignTemplateQueryResourceObject,
)
from ...types.campaign_message_partial_update_query_resource_object import (
    CampaignMessagePartialUpdateQueryResourceObject,
)
from ...types.campaign_partial_update_query_resource_object import CampaignPartialUpdateQueryResourceObject
from ...types.campaign_recipient_estimation_job_create_query_resource_object import (
    CampaignRecipientEstimationJobCreateQueryResourceObject,
)
from ...types.campaign_send_job_create_query_resource_object import CampaignSendJobCreateQueryResourceObject
from ...types.campaign_send_job_partial_update_query_resource_object import (
    CampaignSendJobPartialUpdateQueryResourceObject,
)
from ...types.get_campaign_campaign_messages_request_fields_campaign_item import (
    GetCampaignCampaignMessagesRequestFieldsCampaignItem,
)
from ...types.get_campaign_campaign_messages_request_fields_campaign_message_item import (
    GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem,
)
from ...types.get_campaign_campaign_messages_request_fields_template_item import (
    GetCampaignCampaignMessagesRequestFieldsTemplateItem,
)
from ...types.get_campaign_campaign_messages_request_include_item import GetCampaignCampaignMessagesRequestIncludeItem
from ...types.get_campaign_message_campaign_relationship_list_response import (
    GetCampaignMessageCampaignRelationshipListResponse,
)
from ...types.get_campaign_message_campaign_request_fields_campaign_message_item import (
    GetCampaignMessageCampaignRequestFieldsCampaignMessageItem,
)
from ...types.get_campaign_message_request_fields_campaign_item import GetCampaignMessageRequestFieldsCampaignItem
from ...types.get_campaign_message_request_fields_campaign_message_item import (
    GetCampaignMessageRequestFieldsCampaignMessageItem,
)
from ...types.get_campaign_message_request_fields_template_item import GetCampaignMessageRequestFieldsTemplateItem
from ...types.get_campaign_message_request_include_item import GetCampaignMessageRequestIncludeItem
from ...types.get_campaign_message_response import GetCampaignMessageResponse
from ...types.get_campaign_message_response_collection_compound_document import (
    GetCampaignMessageResponseCollectionCompoundDocument,
)
from ...types.get_campaign_message_response_compound_document import GetCampaignMessageResponseCompoundDocument
from ...types.get_campaign_message_template_relationship_list_response import (
    GetCampaignMessageTemplateRelationshipListResponse,
)
from ...types.get_campaign_message_template_request_fields_template_item import (
    GetCampaignMessageTemplateRequestFieldsTemplateItem,
)
from ...types.get_campaign_messages_relationship_list_response_collection import (
    GetCampaignMessagesRelationshipListResponseCollection,
)
from ...types.get_campaign_recipient_estimation_job_response import GetCampaignRecipientEstimationJobResponse
from ...types.get_campaign_recipient_estimation_response import GetCampaignRecipientEstimationResponse
from ...types.get_campaign_request_fields_campaign_item import GetCampaignRequestFieldsCampaignItem
from ...types.get_campaign_request_fields_campaign_message_item import GetCampaignRequestFieldsCampaignMessageItem
from ...types.get_campaign_request_include_item import GetCampaignRequestIncludeItem
from ...types.get_campaign_response_collection_compound_document import GetCampaignResponseCollectionCompoundDocument
from ...types.get_campaign_response_compound_document import GetCampaignResponseCompoundDocument
from ...types.get_campaign_send_job_response import GetCampaignSendJobResponse
from ...types.get_campaign_tag_relationship_list_response_collection import (
    GetCampaignTagRelationshipListResponseCollection,
)
from ...types.get_campaigns_request_fields_campaign_item import GetCampaignsRequestFieldsCampaignItem
from ...types.get_campaigns_request_fields_campaign_message_item import GetCampaignsRequestFieldsCampaignMessageItem
from ...types.get_campaigns_request_include_item import GetCampaignsRequestIncludeItem
from ...types.get_campaigns_request_sort import GetCampaignsRequestSort
from ...types.get_tag_response_collection import GetTagResponseCollection
from ...types.get_template_response import GetTemplateResponse
from ...types.patch_campaign_message_response import PatchCampaignMessageResponse
from ...types.patch_campaign_response import PatchCampaignResponse
from ...types.post_campaign_message_response import PostCampaignMessageResponse
from ...types.post_campaign_response import PostCampaignResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CampaignsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_campaigns(
        self,
        *,
        filter: str,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignsRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignsRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignsRequestFieldsCampaignItem], typing.List[GetCampaignsRequestFieldsCampaignItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[GetCampaignsRequestIncludeItem], typing.List[GetCampaignsRequestIncludeItem]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCampaignsRequestSort] = None,
    ) -> GetCampaignResponseCollectionCompoundDocument:
        """
        Returns some or all campaigns based on filters.

        A channel filter is required to list campaigns. Please provide either:
        `?filter=equals(messages.channel,'email')` to list email campaigns, or
        `?filter=equals(messages.channel,'sms')` to list SMS campaigns.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - filter: str. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`messages.channel`: `equals`<br>`name`: `contains`<br>`status`: `any`, `equals`<br>`archived`: `equals`<br>`created_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`scheduled_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`updated_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignsRequestFieldsCampaignMessageItem], typing.List[GetCampaignsRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignsRequestFieldsCampaignItem], typing.List[GetCampaignsRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignsRequestIncludeItem], typing.List[GetCampaignsRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCampaignsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaigns"),
            params=remove_none_from_dict(
                {
                    "filter": filter,
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[tag]": fields_tag,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_campaign(self, *, data: CampaignCreateQueryResourceObject) -> PostCampaignResponse:
        """
        Creates a campaign given a set of parameters, then returns it.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaigns"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignRequestFieldsCampaignItem], typing.List[GetCampaignRequestFieldsCampaignItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[GetCampaignRequestIncludeItem], typing.List[GetCampaignRequestIncludeItem]
        ],
    ) -> GetCampaignResponseCompoundDocument:
        """
        Returns a specific campaign based on a required id.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The campaign ID to be retrieved

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignRequestFieldsCampaignMessageItem], typing.List[GetCampaignRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignRequestFieldsCampaignItem], typing.List[GetCampaignRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignRequestIncludeItem], typing.List[GetCampaignRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[tag]": fields_tag,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_campaign(self, id: str, *, data: CampaignPartialUpdateQueryResourceObject) -> PatchCampaignResponse:
        """
        Update a campaign with the given campaign ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The campaign ID to be retrieved

            - data: CampaignPartialUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_campaign(self, id: str) -> None:
        """
        Delete a campaign with the given campaign ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The campaign ID to be deleted
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_message(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignMessageRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsCampaignItem],
            typing.List[GetCampaignMessageRequestFieldsCampaignItem],
        ],
        fields_template: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsTemplateItem],
            typing.List[GetCampaignMessageRequestFieldsTemplateItem],
        ],
        include: typing.Union[
            typing.Optional[GetCampaignMessageRequestIncludeItem], typing.List[GetCampaignMessageRequestIncludeItem]
        ],
    ) -> GetCampaignMessageResponseCompoundDocument:
        """
        Returns a specific message based on a required id.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The message ID to be retrieved

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsCampaignMessageItem], typing.List[GetCampaignMessageRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsCampaignItem], typing.List[GetCampaignMessageRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_template: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsTemplateItem], typing.List[GetCampaignMessageRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignMessageRequestIncludeItem], typing.List[GetCampaignMessageRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[template]": fields_template,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_campaign_message(
        self, id: str, *, data: CampaignMessagePartialUpdateQueryResourceObject
    ) -> PatchCampaignMessageResponse:
        """
        Update a campaign message<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The message ID to be retrieved

            - data: CampaignMessagePartialUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_send_job(
        self,
        id: str,
        *,
        fields_campaign_send_job: typing.Union[
            typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]
        ],
    ) -> GetCampaignSendJobResponse:
        """
        Get a campaign send job<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign to send

            - fields_campaign_send_job: typing.Union[typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-send-jobs/{id}"),
            params=remove_none_from_dict({"fields[campaign-send-job]": fields_campaign_send_job}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignSendJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_campaign_send_job(self, id: str, *, data: CampaignSendJobPartialUpdateQueryResourceObject) -> None:
        """
        Permanently cancel the campaign, setting the status to CANCELED or
        revert the campaign, setting the status back to DRAFT<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The ID of the currently sending campaign to cancel or revert

            - data: CampaignSendJobPartialUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-send-jobs/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_recipient_estimation_job(
        self,
        id: str,
        *,
        fields_campaign_recipient_estimation_job: typing.Union[
            typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]
        ],
    ) -> GetCampaignRecipientEstimationJobResponse:
        """
        Retrieve the status of a recipient estimation job triggered
        with the `Create Campaign Recipient Estimation Job` endpoint.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign to get recipient estimation status

            - fields_campaign_recipient_estimation_job: typing.Union[typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-recipient-estimation-jobs/{id}"
            ),
            params=remove_none_from_dict(
                {"fields[campaign-recipient-estimation-job]": fields_campaign_recipient_estimation_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignRecipientEstimationJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_recipient_estimation(
        self,
        id: str,
        *,
        fields_campaign_recipient_estimation: typing.Union[
            typing.Optional[typing_extensions.Literal["estimated_recipient_count"]],
            typing.List[typing_extensions.Literal["estimated_recipient_count"]],
        ],
    ) -> GetCampaignRecipientEstimationResponse:
        """
        Get the estimated recipient count for a campaign with the provided campaign ID.
        You can refresh this count by using the `Create Campaign Recipient Estimation Job` endpoint.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign for which to get the estimated number of recipients

            - fields_campaign_recipient_estimation: typing.Union[typing.Optional[typing_extensions.Literal["estimated_recipient_count"]], typing.List[typing_extensions.Literal["estimated_recipient_count"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-recipient-estimations/{id}"),
            params=remove_none_from_dict(
                {"fields[campaign-recipient-estimation]": fields_campaign_recipient_estimation}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignRecipientEstimationResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_campaign_clone(self, *, data: CampaignCloneQueryResourceObject) -> PostCampaignResponse:
        """
        Clones an existing campaign, returning a new campaign based on the original with a new ID and name.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignCloneQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-clone"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_campaign_message_assign_template(
        self, *, data: CampaignMessageAssignTemplateQueryResourceObject
    ) -> PostCampaignMessageResponse:
        """
        Creates a non-reusable version of the template and assigns it to the message.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignMessageAssignTemplateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-message-assign-template"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_campaign_send_job(self, *, data: CampaignSendJobCreateQueryResourceObject) -> None:
        """
        Trigger a campaign to send asynchronously<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignSendJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-send-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_campaign_recipient_estimation_job(
        self, *, data: CampaignRecipientEstimationJobCreateQueryResourceObject
    ) -> None:
        """
        Trigger an asynchronous job to update the estimated number of recipients
        for the given campaign ID. Use the `Get Campaign Recipient Estimation
        Job` endpoint to retrieve the status of this estimation job. Use the
        `Get Campaign Recipient Estimation` endpoint to retrieve the estimated
        recipient count for a given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignRecipientEstimationJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-recipient-estimation-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_message_relationships_campaign(
        self, id: str
    ) -> GetCampaignMessageCampaignRelationshipListResponse:
        """
        Returns the ID of the related campaign<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/relationships/campaign"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageCampaignRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_message_campaign(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem],
        ],
    ) -> GetCampaignMessageResponse:
        """
        Return the related campaign<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem], typing.List[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/campaign"),
            params=remove_none_from_dict({"fields[campaign-message]": fields_campaign_message}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_message_relationships_template(
        self, id: str
    ) -> GetCampaignMessageTemplateRelationshipListResponse:
        """
        Returns the ID of the related template<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`
        `templates:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/relationships/template"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageTemplateRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_message_template(
        self,
        id: str,
        *,
        fields_template: typing.Union[
            typing.Optional[GetCampaignMessageTemplateRequestFieldsTemplateItem],
            typing.List[GetCampaignMessageTemplateRequestFieldsTemplateItem],
        ],
    ) -> GetTemplateResponse:
        """
        Return the related template<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`
        `templates:read`

        Parameters:
            - id: str.

            - fields_template: typing.Union[typing.Optional[GetCampaignMessageTemplateRequestFieldsTemplateItem], typing.List[GetCampaignMessageTemplateRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/template"),
            params=remove_none_from_dict({"fields[template]": fields_template}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_relationships_tags(self, id: str) -> GetCampaignTagRelationshipListResponseCollection:
        """
        Returns the IDs of all tags associated with the given campaign.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/relationships/tags"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignTagRelationshipListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_tags(
        self,
        id: str,
        *,
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
    ) -> GetTagResponseCollection:
        """
        Return all tags that belong to the given campaign.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/tags"),
            params=remove_none_from_dict({"fields[tag]": fields_tag}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_relationships_campaign_messages(
        self, id: str
    ) -> GetCampaignMessagesRelationshipListResponseCollection:
        """
        Returns the IDs of all messages associated with the given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/relationships/campaign-messages"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessagesRelationshipListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_campaign_campaign_messages(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignItem],
        ],
        fields_template: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsTemplateItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsTemplateItem],
        ],
        include: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestIncludeItem],
            typing.List[GetCampaignCampaignMessagesRequestIncludeItem],
        ],
    ) -> GetCampaignMessageResponseCollectionCompoundDocument:
        """
        Return all messages that belong to the given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem], typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignItem], typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_template: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsTemplateItem], typing.List[GetCampaignCampaignMessagesRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestIncludeItem], typing.List[GetCampaignCampaignMessagesRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/campaign-messages"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[template]": fields_template,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCampaignsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_campaigns(
        self,
        *,
        filter: str,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignsRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignsRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignsRequestFieldsCampaignItem], typing.List[GetCampaignsRequestFieldsCampaignItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[GetCampaignsRequestIncludeItem], typing.List[GetCampaignsRequestIncludeItem]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCampaignsRequestSort] = None,
    ) -> GetCampaignResponseCollectionCompoundDocument:
        """
        Returns some or all campaigns based on filters.

        A channel filter is required to list campaigns. Please provide either:
        `?filter=equals(messages.channel,'email')` to list email campaigns, or
        `?filter=equals(messages.channel,'sms')` to list SMS campaigns.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - filter: str. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`messages.channel`: `equals`<br>`name`: `contains`<br>`status`: `any`, `equals`<br>`archived`: `equals`<br>`created_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`scheduled_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`updated_at`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignsRequestFieldsCampaignMessageItem], typing.List[GetCampaignsRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignsRequestFieldsCampaignItem], typing.List[GetCampaignsRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignsRequestIncludeItem], typing.List[GetCampaignsRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCampaignsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaigns"),
            params=remove_none_from_dict(
                {
                    "filter": filter,
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[tag]": fields_tag,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_campaign(self, *, data: CampaignCreateQueryResourceObject) -> PostCampaignResponse:
        """
        Creates a campaign given a set of parameters, then returns it.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaigns"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignRequestFieldsCampaignItem], typing.List[GetCampaignRequestFieldsCampaignItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[GetCampaignRequestIncludeItem], typing.List[GetCampaignRequestIncludeItem]
        ],
    ) -> GetCampaignResponseCompoundDocument:
        """
        Returns a specific campaign based on a required id.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The campaign ID to be retrieved

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignRequestFieldsCampaignMessageItem], typing.List[GetCampaignRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignRequestFieldsCampaignItem], typing.List[GetCampaignRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignRequestIncludeItem], typing.List[GetCampaignRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[tag]": fields_tag,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_campaign(
        self, id: str, *, data: CampaignPartialUpdateQueryResourceObject
    ) -> PatchCampaignResponse:
        """
        Update a campaign with the given campaign ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The campaign ID to be retrieved

            - data: CampaignPartialUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_campaign(self, id: str) -> None:
        """
        Delete a campaign with the given campaign ID.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The campaign ID to be deleted
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_message(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignMessageRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsCampaignItem],
            typing.List[GetCampaignMessageRequestFieldsCampaignItem],
        ],
        fields_template: typing.Union[
            typing.Optional[GetCampaignMessageRequestFieldsTemplateItem],
            typing.List[GetCampaignMessageRequestFieldsTemplateItem],
        ],
        include: typing.Union[
            typing.Optional[GetCampaignMessageRequestIncludeItem], typing.List[GetCampaignMessageRequestIncludeItem]
        ],
    ) -> GetCampaignMessageResponseCompoundDocument:
        """
        Returns a specific message based on a required id.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The message ID to be retrieved

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsCampaignMessageItem], typing.List[GetCampaignMessageRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsCampaignItem], typing.List[GetCampaignMessageRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_template: typing.Union[typing.Optional[GetCampaignMessageRequestFieldsTemplateItem], typing.List[GetCampaignMessageRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignMessageRequestIncludeItem], typing.List[GetCampaignMessageRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[template]": fields_template,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_campaign_message(
        self, id: str, *, data: CampaignMessagePartialUpdateQueryResourceObject
    ) -> PatchCampaignMessageResponse:
        """
        Update a campaign message<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The message ID to be retrieved

            - data: CampaignMessagePartialUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_send_job(
        self,
        id: str,
        *,
        fields_campaign_send_job: typing.Union[
            typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]
        ],
    ) -> GetCampaignSendJobResponse:
        """
        Get a campaign send job<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign to send

            - fields_campaign_send_job: typing.Union[typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-send-jobs/{id}"),
            params=remove_none_from_dict({"fields[campaign-send-job]": fields_campaign_send_job}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignSendJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_campaign_send_job(self, id: str, *, data: CampaignSendJobPartialUpdateQueryResourceObject) -> None:
        """
        Permanently cancel the campaign, setting the status to CANCELED or
        revert the campaign, setting the status back to DRAFT<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - id: str. The ID of the currently sending campaign to cancel or revert

            - data: CampaignSendJobPartialUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-send-jobs/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_recipient_estimation_job(
        self,
        id: str,
        *,
        fields_campaign_recipient_estimation_job: typing.Union[
            typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]
        ],
    ) -> GetCampaignRecipientEstimationJobResponse:
        """
        Retrieve the status of a recipient estimation job triggered
        with the `Create Campaign Recipient Estimation Job` endpoint.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign to get recipient estimation status

            - fields_campaign_recipient_estimation_job: typing.Union[typing.Optional[typing_extensions.Literal["status"]], typing.List[typing_extensions.Literal["status"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-recipient-estimation-jobs/{id}"
            ),
            params=remove_none_from_dict(
                {"fields[campaign-recipient-estimation-job]": fields_campaign_recipient_estimation_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignRecipientEstimationJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_recipient_estimation(
        self,
        id: str,
        *,
        fields_campaign_recipient_estimation: typing.Union[
            typing.Optional[typing_extensions.Literal["estimated_recipient_count"]],
            typing.List[typing_extensions.Literal["estimated_recipient_count"]],
        ],
    ) -> GetCampaignRecipientEstimationResponse:
        """
        Get the estimated recipient count for a campaign with the provided campaign ID.
        You can refresh this count by using the `Create Campaign Recipient Estimation Job` endpoint.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str. The ID of the campaign for which to get the estimated number of recipients

            - fields_campaign_recipient_estimation: typing.Union[typing.Optional[typing_extensions.Literal["estimated_recipient_count"]], typing.List[typing_extensions.Literal["estimated_recipient_count"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-recipient-estimations/{id}"),
            params=remove_none_from_dict(
                {"fields[campaign-recipient-estimation]": fields_campaign_recipient_estimation}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignRecipientEstimationResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_campaign_clone(self, *, data: CampaignCloneQueryResourceObject) -> PostCampaignResponse:
        """
        Clones an existing campaign, returning a new campaign based on the original with a new ID and name.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignCloneQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-clone"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_campaign_message_assign_template(
        self, *, data: CampaignMessageAssignTemplateQueryResourceObject
    ) -> PostCampaignMessageResponse:
        """
        Creates a non-reusable version of the template and assigns it to the message.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignMessageAssignTemplateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-message-assign-template"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_campaign_send_job(self, *, data: CampaignSendJobCreateQueryResourceObject) -> None:
        """
        Trigger a campaign to send asynchronously<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignSendJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-send-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_campaign_recipient_estimation_job(
        self, *, data: CampaignRecipientEstimationJobCreateQueryResourceObject
    ) -> None:
        """
        Trigger an asynchronous job to update the estimated number of recipients
        for the given campaign ID. Use the `Get Campaign Recipient Estimation
        Job` endpoint to retrieve the status of this estimation job. Use the
        `Get Campaign Recipient Estimation` endpoint to retrieve the estimated
        recipient count for a given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:write`

        Parameters:
            - data: CampaignRecipientEstimationJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/campaign-recipient-estimation-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_message_relationships_campaign(
        self, id: str
    ) -> GetCampaignMessageCampaignRelationshipListResponse:
        """
        Returns the ID of the related campaign<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/relationships/campaign"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageCampaignRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_message_campaign(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem],
        ],
    ) -> GetCampaignMessageResponse:
        """
        Return the related campaign<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem], typing.List[GetCampaignMessageCampaignRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/campaign"),
            params=remove_none_from_dict({"fields[campaign-message]": fields_campaign_message}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_message_relationships_template(
        self, id: str
    ) -> GetCampaignMessageTemplateRelationshipListResponse:
        """
        Returns the ID of the related template<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`
        `templates:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/relationships/template"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageTemplateRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_message_template(
        self,
        id: str,
        *,
        fields_template: typing.Union[
            typing.Optional[GetCampaignMessageTemplateRequestFieldsTemplateItem],
            typing.List[GetCampaignMessageTemplateRequestFieldsTemplateItem],
        ],
    ) -> GetTemplateResponse:
        """
        Return the related template<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`
        `templates:read`

        Parameters:
            - id: str.

            - fields_template: typing.Union[typing.Optional[GetCampaignMessageTemplateRequestFieldsTemplateItem], typing.List[GetCampaignMessageTemplateRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaign-messages/{id}/template"),
            params=remove_none_from_dict({"fields[template]": fields_template}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTemplateResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_relationships_tags(self, id: str) -> GetCampaignTagRelationshipListResponseCollection:
        """
        Returns the IDs of all tags associated with the given campaign.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/relationships/tags"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignTagRelationshipListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_tags(
        self,
        id: str,
        *,
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
    ) -> GetTagResponseCollection:
        """
        Return all tags that belong to the given campaign.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/tags"),
            params=remove_none_from_dict({"fields[tag]": fields_tag}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_relationships_campaign_messages(
        self, id: str
    ) -> GetCampaignMessagesRelationshipListResponseCollection:
        """
        Returns the IDs of all messages associated with the given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/relationships/campaign-messages"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessagesRelationshipListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_campaign_campaign_messages(
        self,
        id: str,
        *,
        fields_campaign_message: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem],
        ],
        fields_campaign: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignItem],
        ],
        fields_template: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestFieldsTemplateItem],
            typing.List[GetCampaignCampaignMessagesRequestFieldsTemplateItem],
        ],
        include: typing.Union[
            typing.Optional[GetCampaignCampaignMessagesRequestIncludeItem],
            typing.List[GetCampaignCampaignMessagesRequestIncludeItem],
        ],
    ) -> GetCampaignMessageResponseCollectionCompoundDocument:
        """
        Return all messages that belong to the given campaign.<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `campaigns:read`

        Parameters:
            - id: str.

            - fields_campaign_message: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem], typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignMessageItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_campaign: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsCampaignItem], typing.List[GetCampaignCampaignMessagesRequestFieldsCampaignItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_template: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestFieldsTemplateItem], typing.List[GetCampaignCampaignMessagesRequestFieldsTemplateItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetCampaignCampaignMessagesRequestIncludeItem], typing.List[GetCampaignCampaignMessagesRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/campaigns/{id}/campaign-messages"),
            params=remove_none_from_dict(
                {
                    "fields[campaign-message]": fields_campaign_message,
                    "fields[campaign]": fields_campaign,
                    "fields[template]": fields_template,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCampaignMessageResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
