# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.delete_tag_group_response import DeleteTagGroupResponse
from ...types.get_tag_campaign_relationships_response_collection import GetTagCampaignRelationshipsResponseCollection
from ...types.get_tag_flow_relationships_response_collection import GetTagFlowRelationshipsResponseCollection
from ...types.get_tag_group_request_fields_tag_group_item import GetTagGroupRequestFieldsTagGroupItem
from ...types.get_tag_group_response import GetTagGroupResponse
from ...types.get_tag_group_response_collection import GetTagGroupResponseCollection
from ...types.get_tag_group_tag_relationships_response_collection import GetTagGroupTagRelationshipsResponseCollection
from ...types.get_tag_groups_request_fields_tag_group_item import GetTagGroupsRequestFieldsTagGroupItem
from ...types.get_tag_groups_request_sort import GetTagGroupsRequestSort
from ...types.get_tag_list_relationships_response_collection import GetTagListRelationshipsResponseCollection
from ...types.get_tag_request_fields_tag_group_item import GetTagRequestFieldsTagGroupItem
from ...types.get_tag_response_collection import GetTagResponseCollection
from ...types.get_tag_response_collection_compound_document import GetTagResponseCollectionCompoundDocument
from ...types.get_tag_response_compound_document import GetTagResponseCompoundDocument
from ...types.get_tag_segment_relationships_response_collection import GetTagSegmentRelationshipsResponseCollection
from ...types.get_tag_tag_group_relationships_response import GetTagTagGroupRelationshipsResponse
from ...types.get_tag_tag_group_request_fields_tag_group_item import GetTagTagGroupRequestFieldsTagGroupItem
from ...types.get_tags_request_fields_tag_group_item import GetTagsRequestFieldsTagGroupItem
from ...types.get_tags_request_sort import GetTagsRequestSort
from ...types.patch_tag_group_response import PatchTagGroupResponse
from ...types.post_tag_group_response import PostTagGroupResponse
from ...types.post_tag_response import PostTagResponse
from ...types.tag_campaign_op import TagCampaignOp
from ...types.tag_create_query_resource_object import TagCreateQueryResourceObject
from ...types.tag_flow_op import TagFlowOp
from ...types.tag_group_create_query_resource_object import TagGroupCreateQueryResourceObject
from ...types.tag_group_update_query_resource_object import TagGroupUpdateQueryResourceObject
from ...types.tag_list_op import TagListOp
from ...types.tag_segment_op import TagSegmentOp
from ...types.tag_update_query_resource_object import TagUpdateQueryResourceObject

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TagsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_tags(
        self,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagsRequestFieldsTagGroupItem], typing.List[GetTagsRequestFieldsTagGroupItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTagsRequestSort] = None,
    ) -> GetTagResponseCollectionCompoundDocument:
        """
        List all tags in an account.

        Tags can be filtered by `name`, and sorted by `name` or `id` in ascending or descending order.

        Returns a maximum of 50 tags per request, which can be paginated with
        [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - fields_tag_group: typing.Union[typing.Optional[GetTagsRequestFieldsTagGroupItem], typing.List[GetTagsRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`name`: `contains`, `ends-with`, `equals`, `starts-with`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTagsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tags"),
            params=remove_none_from_dict(
                {
                    "fields[tag-group]": fields_tag_group,
                    "fields[tag]": fields_tag,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag(self, *, data: TagCreateQueryResourceObject) -> PostTagResponse:
        """
        Create a tag. An account cannot have more than **500** unique tags.

        A tag belongs to a single tag group. If the `tag_group_id` is not specified,
        the tag is added to the account's default tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - data: TagCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tags"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTagResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagRequestFieldsTagGroupItem], typing.List[GetTagRequestFieldsTagGroupItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]
        ],
    ) -> GetTagResponseCompoundDocument:
        """
        Retrieve the tag with the given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str. The Tag ID

            - fields_tag_group: typing.Union[typing.Optional[GetTagRequestFieldsTagGroupItem], typing.List[GetTagRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            params=remove_none_from_dict(
                {"fields[tag-group]": fields_tag_group, "fields[tag]": fields_tag, "include": include}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_tag(self, id: str, *, data: TagUpdateQueryResourceObject) -> None:
        """
        Update the tag with the given tag ID.

        Only a tag's `name` can be changed. A tag cannot be moved from one tag group to another.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag ID

            - data: TagUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag(self, id: str) -> None:
        """
        Delete the tag with the given tag ID. Any associations between the tag and other resources will also be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag ID
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_groups(
        self,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagGroupsRequestFieldsTagGroupItem], typing.List[GetTagGroupsRequestFieldsTagGroupItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTagGroupsRequestSort] = None,
    ) -> GetTagGroupResponseCollection:
        """
        List all tag groups in an account. Every account has one default tag group.

        Tag groups can be filtered by `name`, `exclusive`, and `default`, and sorted by `name` or `id` in ascending or descending order.

        Returns a maximum of 25 tag groups per request, which can be paginated with
        [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - fields_tag_group: typing.Union[typing.Optional[GetTagGroupsRequestFieldsTagGroupItem], typing.List[GetTagGroupsRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`name`: `contains`, `ends-with`, `equals`, `starts-with`<br>`exclusive`: `equals`<br>`default`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTagGroupsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tag-groups"),
            params=remove_none_from_dict(
                {"fields[tag-group]": fields_tag_group, "filter": filter, "page[cursor]": page_cursor, "sort": sort}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag_group(self, *, data: TagGroupCreateQueryResourceObject) -> PostTagGroupResponse:
        """
        Create a tag group. An account cannot have more than **50** unique tag groups.

        If `exclusive` is not specified `true` or `false`, the tag group defaults to non-exclusive.

        If a tag group is non-exclusive, any given related resource (campaign, flow, etc.)
        can be linked to multiple tags from that tag group.
        If a tag group is exclusive, any given related resource can only be linked to one tag from that tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - data: TagGroupCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tag-groups"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_group(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagGroupRequestFieldsTagGroupItem], typing.List[GetTagGroupRequestFieldsTagGroupItem]
        ],
    ) -> GetTagGroupResponse:
        """
        Retrieve the tag group with the given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str. The Tag Group ID

            - fields_tag_group: typing.Union[typing.Optional[GetTagGroupRequestFieldsTagGroupItem], typing.List[GetTagGroupRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            params=remove_none_from_dict({"fields[tag-group]": fields_tag_group}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_tag_group(self, id: str, *, data: TagGroupUpdateQueryResourceObject) -> PatchTagGroupResponse:
        """
        Update the tag group with the given tag group ID.

        Only a tag group's `name` can be changed. A tag group's `exclusive` or `default` value cannot be changed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag Group ID

            - data: TagGroupUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag_group(self, id: str) -> DeleteTagGroupResponse:
        """
        Delete the tag group with the given tag group ID.

        Any tags inside that tag group, and any associations between those tags and other resources, will also be removed. The default tag group cannot be deleted.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag Group ID
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_relationships_flows(self, id: str) -> GetTagFlowRelationshipsResponseCollection:
        """
        Returns the IDs of all flows associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagFlowRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag_relationships_flows(self, id: str, *, request: TagFlowOp) -> None:
        """
        Associate a tag with one or more flows. Any flow cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the flow(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagFlowOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag_relationships_flows(self, id: str, *, request: TagFlowOp) -> None:
        """
        Remove a tag's association with one or more flows.


        Use the request body to pass in the ID(s) of the flows(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagFlowOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_relationships_campaigns(self, id: str) -> GetTagCampaignRelationshipsResponseCollection:
        """
        Returns the IDs of all campaigns associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagCampaignRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag_relationships_campaigns(self, id: str, *, request: TagCampaignOp) -> None:
        """
        Associate a tag with one or more campaigns. Any campaign cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the campaign(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagCampaignOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag_relationships_campaigns(self, id: str, *, request: TagCampaignOp) -> None:
        """
        Remove a tag's association with one or more campaigns.


        Use the request body to pass in the ID(s) of the campaign(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagCampaignOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_relationships_lists(self, id: str) -> GetTagListRelationshipsResponseCollection:
        """
        Returns the IDs of all lists associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagListRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag_relationships_lists(self, id: str, *, request: TagListOp) -> None:
        """
        Associate a tag with one or more lists. Any list cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the lists(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagListOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag_relationships_lists(self, id: str, *, request: TagListOp) -> None:
        """
        Remove a tag's association with one or more lists.


        Use the request body to pass in the ID(s) of the list(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagListOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_relationships_segments(self, id: str) -> GetTagSegmentRelationshipsResponseCollection:
        """
        Returns the IDs of all segments associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagSegmentRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_tag_relationships_segments(self, id: str, *, request: TagSegmentOp) -> None:
        """
        Associate a tag with one or more segments. Any segment cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the segments(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagSegmentOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_tag_relationships_segments(self, id: str, *, request: TagSegmentOp) -> None:
        """
        Remove a tag's association with one or more segments.


        Use the request body to pass in the ID(s) of the segments(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagSegmentOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_relationships_tag_group(self, id: str) -> GetTagTagGroupRelationshipsResponse:
        """
        Returns the id of the tag group related to the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/tag-group"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagTagGroupRelationshipsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_group_relationships_tags(self, id: str) -> GetTagGroupTagRelationshipsResponseCollection:
        """
        Returns the tag IDs of all tags inside the given tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}/relationships/tags"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupTagRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_tag_group(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagTagGroupRequestFieldsTagGroupItem],
            typing.List[GetTagTagGroupRequestFieldsTagGroupItem],
        ],
    ) -> GetTagGroupResponse:
        """
        Returns the tag group resource for a given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag_group: typing.Union[typing.Optional[GetTagTagGroupRequestFieldsTagGroupItem], typing.List[GetTagTagGroupRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/tag-group"),
            params=remove_none_from_dict({"fields[tag-group]": fields_tag_group}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_tag_group_tags(
        self,
        id: str,
        *,
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
    ) -> GetTagResponseCollection:
        """
        Return the tags for a given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}/tags"),
            params=remove_none_from_dict({"fields[tag]": fields_tag}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTagsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_tags(
        self,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagsRequestFieldsTagGroupItem], typing.List[GetTagsRequestFieldsTagGroupItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTagsRequestSort] = None,
    ) -> GetTagResponseCollectionCompoundDocument:
        """
        List all tags in an account.

        Tags can be filtered by `name`, and sorted by `name` or `id` in ascending or descending order.

        Returns a maximum of 50 tags per request, which can be paginated with
        [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - fields_tag_group: typing.Union[typing.Optional[GetTagsRequestFieldsTagGroupItem], typing.List[GetTagsRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`name`: `contains`, `ends-with`, `equals`, `starts-with`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTagsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tags"),
            params=remove_none_from_dict(
                {
                    "fields[tag-group]": fields_tag_group,
                    "fields[tag]": fields_tag,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag(self, *, data: TagCreateQueryResourceObject) -> PostTagResponse:
        """
        Create a tag. An account cannot have more than **500** unique tags.

        A tag belongs to a single tag group. If the `tag_group_id` is not specified,
        the tag is added to the account's default tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - data: TagCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tags"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTagResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagRequestFieldsTagGroupItem], typing.List[GetTagRequestFieldsTagGroupItem]
        ],
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]
        ],
    ) -> GetTagResponseCompoundDocument:
        """
        Retrieve the tag with the given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str. The Tag ID

            - fields_tag_group: typing.Union[typing.Optional[GetTagRequestFieldsTagGroupItem], typing.List[GetTagRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["tag-group"]], typing.List[typing_extensions.Literal["tag-group"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            params=remove_none_from_dict(
                {"fields[tag-group]": fields_tag_group, "fields[tag]": fields_tag, "include": include}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_tag(self, id: str, *, data: TagUpdateQueryResourceObject) -> None:
        """
        Update the tag with the given tag ID.

        Only a tag's `name` can be changed. A tag cannot be moved from one tag group to another.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag ID

            - data: TagUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag(self, id: str) -> None:
        """
        Delete the tag with the given tag ID. Any associations between the tag and other resources will also be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag ID
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_groups(
        self,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagGroupsRequestFieldsTagGroupItem], typing.List[GetTagGroupsRequestFieldsTagGroupItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetTagGroupsRequestSort] = None,
    ) -> GetTagGroupResponseCollection:
        """
        List all tag groups in an account. Every account has one default tag group.

        Tag groups can be filtered by `name`, `exclusive`, and `default`, and sorted by `name` or `id` in ascending or descending order.

        Returns a maximum of 25 tag groups per request, which can be paginated with
        [cursor-based pagination](https://developers.klaviyo.com/en/v2022-10-17/reference/api_overview#pagination).<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - fields_tag_group: typing.Union[typing.Optional[GetTagGroupsRequestFieldsTagGroupItem], typing.List[GetTagGroupsRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`name`: `contains`, `ends-with`, `equals`, `starts-with`<br>`exclusive`: `equals`<br>`default`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetTagGroupsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tag-groups"),
            params=remove_none_from_dict(
                {"fields[tag-group]": fields_tag_group, "filter": filter, "page[cursor]": page_cursor, "sort": sort}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag_group(self, *, data: TagGroupCreateQueryResourceObject) -> PostTagGroupResponse:
        """
        Create a tag group. An account cannot have more than **50** unique tag groups.

        If `exclusive` is not specified `true` or `false`, the tag group defaults to non-exclusive.

        If a tag group is non-exclusive, any given related resource (campaign, flow, etc.)
        can be linked to multiple tags from that tag group.
        If a tag group is exclusive, any given related resource can only be linked to one tag from that tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - data: TagGroupCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tag-groups"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_group(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagGroupRequestFieldsTagGroupItem], typing.List[GetTagGroupRequestFieldsTagGroupItem]
        ],
    ) -> GetTagGroupResponse:
        """
        Retrieve the tag group with the given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str. The Tag Group ID

            - fields_tag_group: typing.Union[typing.Optional[GetTagGroupRequestFieldsTagGroupItem], typing.List[GetTagGroupRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            params=remove_none_from_dict({"fields[tag-group]": fields_tag_group}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_tag_group(self, id: str, *, data: TagGroupUpdateQueryResourceObject) -> PatchTagGroupResponse:
        """
        Update the tag group with the given tag group ID.

        Only a tag group's `name` can be changed. A tag group's `exclusive` or `default` value cannot be changed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag Group ID

            - data: TagGroupUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag_group(self, id: str) -> DeleteTagGroupResponse:
        """
        Delete the tag group with the given tag group ID.

        Any tags inside that tag group, and any associations between those tags and other resources, will also be removed. The default tag group cannot be deleted.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`
        `tags:write`

        Parameters:
            - id: str. The Tag Group ID
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_relationships_flows(self, id: str) -> GetTagFlowRelationshipsResponseCollection:
        """
        Returns the IDs of all flows associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagFlowRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag_relationships_flows(self, id: str, *, request: TagFlowOp) -> None:
        """
        Associate a tag with one or more flows. Any flow cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the flow(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagFlowOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag_relationships_flows(self, id: str, *, request: TagFlowOp) -> None:
        """
        Remove a tag's association with one or more flows.


        Use the request body to pass in the ID(s) of the flows(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `flows:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagFlowOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/flows"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_relationships_campaigns(self, id: str) -> GetTagCampaignRelationshipsResponseCollection:
        """
        Returns the IDs of all campaigns associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagCampaignRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag_relationships_campaigns(self, id: str, *, request: TagCampaignOp) -> None:
        """
        Associate a tag with one or more campaigns. Any campaign cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the campaign(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagCampaignOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag_relationships_campaigns(self, id: str, *, request: TagCampaignOp) -> None:
        """
        Remove a tag's association with one or more campaigns.


        Use the request body to pass in the ID(s) of the campaign(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `campaigns:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagCampaignOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/campaigns"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_relationships_lists(self, id: str) -> GetTagListRelationshipsResponseCollection:
        """
        Returns the IDs of all lists associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagListRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag_relationships_lists(self, id: str, *, request: TagListOp) -> None:
        """
        Associate a tag with one or more lists. Any list cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the lists(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagListOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag_relationships_lists(self, id: str, *, request: TagListOp) -> None:
        """
        Remove a tag's association with one or more lists.


        Use the request body to pass in the ID(s) of the list(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagListOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/lists"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_relationships_segments(self, id: str) -> GetTagSegmentRelationshipsResponseCollection:
        """
        Returns the IDs of all segments associated with the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:read`
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagSegmentRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_tag_relationships_segments(self, id: str, *, request: TagSegmentOp) -> None:
        """
        Associate a tag with one or more segments. Any segment cannot be associated with more than **100** tags.


        Use the request body to pass in the ID(s) of the segments(s) that will be associated with the tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagSegmentOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_tag_relationships_segments(self, id: str, *, request: TagSegmentOp) -> None:
        """
        Remove a tag's association with one or more segments.


        Use the request body to pass in the ID(s) of the segments(s) whose association with the tag
        will be removed.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `segments:write`
        `tags:write`

        Parameters:
            - id: str.

            - request: TagSegmentOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/segments"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_relationships_tag_group(self, id: str) -> GetTagTagGroupRelationshipsResponse:
        """
        Returns the id of the tag group related to the given tag.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/relationships/tag-group"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagTagGroupRelationshipsResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_group_relationships_tags(self, id: str) -> GetTagGroupTagRelationshipsResponseCollection:
        """
        Returns the tag IDs of all tags inside the given tag group.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}/relationships/tags"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupTagRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_tag_group(
        self,
        id: str,
        *,
        fields_tag_group: typing.Union[
            typing.Optional[GetTagTagGroupRequestFieldsTagGroupItem],
            typing.List[GetTagTagGroupRequestFieldsTagGroupItem],
        ],
    ) -> GetTagGroupResponse:
        """
        Returns the tag group resource for a given tag ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag_group: typing.Union[typing.Optional[GetTagTagGroupRequestFieldsTagGroupItem], typing.List[GetTagTagGroupRequestFieldsTagGroupItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tags/{id}/tag-group"),
            params=remove_none_from_dict({"fields[tag-group]": fields_tag_group}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagGroupResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_tag_group_tags(
        self,
        id: str,
        *,
        fields_tag: typing.Union[
            typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]
        ],
    ) -> GetTagResponseCollection:
        """
        Return the tags for a given tag group ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `tags:read`

        Parameters:
            - id: str.

            - fields_tag: typing.Union[typing.Optional[typing_extensions.Literal["name"]], typing.List[typing_extensions.Literal["name"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tag-groups/{id}/tags"),
            params=remove_none_from_dict({"fields[tag]": fields_tag}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetTagResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
