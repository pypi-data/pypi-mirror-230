# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.event_create_query_v_2 import EventCreateQueryV2
from ...types.get_event_metric_request_fields_metric_item import GetEventMetricRequestFieldsMetricItem
from ...types.get_event_metrics_relationship_list_response import GetEventMetricsRelationshipListResponse
from ...types.get_event_profile_request_fields_profile_item import GetEventProfileRequestFieldsProfileItem
from ...types.get_event_profiles_relationship_list_response import GetEventProfilesRelationshipListResponse
from ...types.get_event_request_fields_event_item import GetEventRequestFieldsEventItem
from ...types.get_event_request_fields_metric_item import GetEventRequestFieldsMetricItem
from ...types.get_event_request_fields_profile_item import GetEventRequestFieldsProfileItem
from ...types.get_event_request_include_item import GetEventRequestIncludeItem
from ...types.get_event_response_collection_compound_document import GetEventResponseCollectionCompoundDocument
from ...types.get_event_response_compound_document import GetEventResponseCompoundDocument
from ...types.get_events_request_fields_event_item import GetEventsRequestFieldsEventItem
from ...types.get_events_request_fields_metric_item import GetEventsRequestFieldsMetricItem
from ...types.get_events_request_fields_profile_item import GetEventsRequestFieldsProfileItem
from ...types.get_events_request_include_item import GetEventsRequestIncludeItem
from ...types.get_events_request_sort import GetEventsRequestSort
from ...types.get_metric_response import GetMetricResponse
from ...types.get_profile_response import GetProfileResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class EventsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_events(
        self,
        *,
        fields_event: typing.Union[
            typing.Optional[GetEventsRequestFieldsEventItem], typing.List[GetEventsRequestFieldsEventItem]
        ],
        fields_metric: typing.Union[
            typing.Optional[GetEventsRequestFieldsMetricItem], typing.List[GetEventsRequestFieldsMetricItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventsRequestFieldsProfileItem], typing.List[GetEventsRequestFieldsProfileItem]
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[typing.Optional[GetEventsRequestIncludeItem], typing.List[GetEventsRequestIncludeItem]],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetEventsRequestSort] = None,
    ) -> GetEventResponseCollectionCompoundDocument:
        """
        Get all events in an account

        Requests can be sorted by the following fields:
        `datetime`, `timestamp`

        Include parameters can be provided to get the following related resource data: `metric`, `profile`

        Returns a maximum of 200 events per page.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`

        Parameters:
            - fields_event: typing.Union[typing.Optional[GetEventsRequestFieldsEventItem], typing.List[GetEventsRequestFieldsEventItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_metric: typing.Union[typing.Optional[GetEventsRequestFieldsMetricItem], typing.List[GetEventsRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetEventsRequestFieldsProfileItem], typing.List[GetEventsRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`metric_id`: `equals`<br>`profile_id`: `equals`<br>`datetime`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`timestamp`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - include: typing.Union[typing.Optional[GetEventsRequestIncludeItem], typing.List[GetEventsRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetEventsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/events"),
            params=remove_none_from_dict(
                {
                    "fields[event]": fields_event,
                    "fields[metric]": fields_metric,
                    "fields[profile]": fields_profile,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_event(self, *, request: EventCreateQueryV2) -> None:
        """
        Create a new event to track a profile's activity.

        Successful response indicates that the event was validated and submitted for processing, but does not guarantee that processing is complete.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:write`

        Parameters:
            - request: EventCreateQueryV2.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/events"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_event(
        self,
        id: str,
        *,
        fields_event: typing.Union[
            typing.Optional[GetEventRequestFieldsEventItem], typing.List[GetEventRequestFieldsEventItem]
        ],
        fields_metric: typing.Union[
            typing.Optional[GetEventRequestFieldsMetricItem], typing.List[GetEventRequestFieldsMetricItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventRequestFieldsProfileItem], typing.List[GetEventRequestFieldsProfileItem]
        ],
        include: typing.Union[typing.Optional[GetEventRequestIncludeItem], typing.List[GetEventRequestIncludeItem]],
    ) -> GetEventResponseCompoundDocument:
        """
        Get an event with the given event ID.

        Include parameters can be provided to get the following related resource data: `metric`, `profile`<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `events:read`

        Parameters:
            - id: str. ID of the event

            - fields_event: typing.Union[typing.Optional[GetEventRequestFieldsEventItem], typing.List[GetEventRequestFieldsEventItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_metric: typing.Union[typing.Optional[GetEventRequestFieldsMetricItem], typing.List[GetEventRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetEventRequestFieldsProfileItem], typing.List[GetEventRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetEventRequestIncludeItem], typing.List[GetEventRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[event]": fields_event,
                    "fields[metric]": fields_metric,
                    "fields[profile]": fields_profile,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_event_metric(
        self,
        id: str,
        *,
        fields_metric: typing.Union[
            typing.Optional[GetEventMetricRequestFieldsMetricItem], typing.List[GetEventMetricRequestFieldsMetricItem]
        ],
    ) -> GetMetricResponse:
        """
        Get the metric for an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `metrics:read`

        Parameters:
            - id: str.

            - fields_metric: typing.Union[typing.Optional[GetEventMetricRequestFieldsMetricItem], typing.List[GetEventMetricRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/metric"),
            params=remove_none_from_dict({"fields[metric]": fields_metric}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetMetricResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_event_profile(
        self,
        id: str,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventProfileRequestFieldsProfileItem],
            typing.List[GetEventProfileRequestFieldsProfileItem],
        ],
    ) -> GetProfileResponse:
        """
        Get the profile associated with an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `profiles:read`

        Parameters:
            - id: str.

            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_profile: typing.Union[typing.Optional[GetEventProfileRequestFieldsProfileItem], typing.List[GetEventProfileRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/profile"),
            params=remove_none_from_dict(
                {"additional-fields[profile]": additional_fields_profile, "fields[profile]": fields_profile}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_event_relationships_metric(self, id: str) -> GetEventMetricsRelationshipListResponse:
        """
        Get a list of related Metrics for an Event<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `metrics:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/relationships/metric"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventMetricsRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_event_relationships_profile(self, id: str) -> GetEventProfilesRelationshipListResponse:
        """
        Get profile [relationships](https://developers.klaviyo.com/en/reference/api_overview#relationships) for an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `profiles:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/relationships/profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventProfilesRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncEventsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_events(
        self,
        *,
        fields_event: typing.Union[
            typing.Optional[GetEventsRequestFieldsEventItem], typing.List[GetEventsRequestFieldsEventItem]
        ],
        fields_metric: typing.Union[
            typing.Optional[GetEventsRequestFieldsMetricItem], typing.List[GetEventsRequestFieldsMetricItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventsRequestFieldsProfileItem], typing.List[GetEventsRequestFieldsProfileItem]
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[typing.Optional[GetEventsRequestIncludeItem], typing.List[GetEventsRequestIncludeItem]],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetEventsRequestSort] = None,
    ) -> GetEventResponseCollectionCompoundDocument:
        """
        Get all events in an account

        Requests can be sorted by the following fields:
        `datetime`, `timestamp`

        Include parameters can be provided to get the following related resource data: `metric`, `profile`

        Returns a maximum of 200 events per page.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`

        Parameters:
            - fields_event: typing.Union[typing.Optional[GetEventsRequestFieldsEventItem], typing.List[GetEventsRequestFieldsEventItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_metric: typing.Union[typing.Optional[GetEventsRequestFieldsMetricItem], typing.List[GetEventsRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetEventsRequestFieldsProfileItem], typing.List[GetEventsRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`metric_id`: `equals`<br>`profile_id`: `equals`<br>`datetime`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`<br>`timestamp`: `greater-or-equal`, `greater-than`, `less-or-equal`, `less-than`

            - include: typing.Union[typing.Optional[GetEventsRequestIncludeItem], typing.List[GetEventsRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetEventsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/events"),
            params=remove_none_from_dict(
                {
                    "fields[event]": fields_event,
                    "fields[metric]": fields_metric,
                    "fields[profile]": fields_profile,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_event(self, *, request: EventCreateQueryV2) -> None:
        """
        Create a new event to track a profile's activity.

        Successful response indicates that the event was validated and submitted for processing, but does not guarantee that processing is complete.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:write`

        Parameters:
            - request: EventCreateQueryV2.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/events"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_event(
        self,
        id: str,
        *,
        fields_event: typing.Union[
            typing.Optional[GetEventRequestFieldsEventItem], typing.List[GetEventRequestFieldsEventItem]
        ],
        fields_metric: typing.Union[
            typing.Optional[GetEventRequestFieldsMetricItem], typing.List[GetEventRequestFieldsMetricItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventRequestFieldsProfileItem], typing.List[GetEventRequestFieldsProfileItem]
        ],
        include: typing.Union[typing.Optional[GetEventRequestIncludeItem], typing.List[GetEventRequestIncludeItem]],
    ) -> GetEventResponseCompoundDocument:
        """
        Get an event with the given event ID.

        Include parameters can be provided to get the following related resource data: `metric`, `profile`<br><br>*Rate limits*:<br>Burst: `10/s`<br>Steady: `150/m`

        **Scopes:**
        `events:read`

        Parameters:
            - id: str. ID of the event

            - fields_event: typing.Union[typing.Optional[GetEventRequestFieldsEventItem], typing.List[GetEventRequestFieldsEventItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_metric: typing.Union[typing.Optional[GetEventRequestFieldsMetricItem], typing.List[GetEventRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetEventRequestFieldsProfileItem], typing.List[GetEventRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetEventRequestIncludeItem], typing.List[GetEventRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[event]": fields_event,
                    "fields[metric]": fields_metric,
                    "fields[profile]": fields_profile,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_event_metric(
        self,
        id: str,
        *,
        fields_metric: typing.Union[
            typing.Optional[GetEventMetricRequestFieldsMetricItem], typing.List[GetEventMetricRequestFieldsMetricItem]
        ],
    ) -> GetMetricResponse:
        """
        Get the metric for an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `metrics:read`

        Parameters:
            - id: str.

            - fields_metric: typing.Union[typing.Optional[GetEventMetricRequestFieldsMetricItem], typing.List[GetEventMetricRequestFieldsMetricItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/metric"),
            params=remove_none_from_dict({"fields[metric]": fields_metric}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetMetricResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_event_profile(
        self,
        id: str,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_profile: typing.Union[
            typing.Optional[GetEventProfileRequestFieldsProfileItem],
            typing.List[GetEventProfileRequestFieldsProfileItem],
        ],
    ) -> GetProfileResponse:
        """
        Get the profile associated with an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `profiles:read`

        Parameters:
            - id: str.

            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_profile: typing.Union[typing.Optional[GetEventProfileRequestFieldsProfileItem], typing.List[GetEventProfileRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/profile"),
            params=remove_none_from_dict(
                {"additional-fields[profile]": additional_fields_profile, "fields[profile]": fields_profile}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_event_relationships_metric(self, id: str) -> GetEventMetricsRelationshipListResponse:
        """
        Get a list of related Metrics for an Event<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `metrics:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/relationships/metric"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventMetricsRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_event_relationships_profile(self, id: str) -> GetEventProfilesRelationshipListResponse:
        """
        Get profile [relationships](https://developers.klaviyo.com/en/reference/api_overview#relationships) for an event with the given event ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `events:read`
        `profiles:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/events/{id}/relationships/profile"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetEventProfilesRelationshipListResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
