# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.get_list_response_collection import GetListResponseCollection
from ...types.get_profile_list_relationships_response_collection import GetProfileListRelationshipsResponseCollection
from ...types.get_profile_lists_request_fields_list_item import GetProfileListsRequestFieldsListItem
from ...types.get_profile_request_fields_list_item import GetProfileRequestFieldsListItem
from ...types.get_profile_request_fields_profile_item import GetProfileRequestFieldsProfileItem
from ...types.get_profile_request_fields_segment_item import GetProfileRequestFieldsSegmentItem
from ...types.get_profile_request_include_item import GetProfileRequestIncludeItem
from ...types.get_profile_response_collection_compound_document import GetProfileResponseCollectionCompoundDocument
from ...types.get_profile_response_compound_document import GetProfileResponseCompoundDocument
from ...types.get_profile_segment_relationships_response_collection import (
    GetProfileSegmentRelationshipsResponseCollection,
)
from ...types.get_profile_segments_request_fields_segment_item import GetProfileSegmentsRequestFieldsSegmentItem
from ...types.get_profiles_request_fields_profile_item import GetProfilesRequestFieldsProfileItem
from ...types.get_profiles_request_sort import GetProfilesRequestSort
from ...types.get_segment_response_collection import GetSegmentResponseCollection
from ...types.patch_profile_response import PatchProfileResponse
from ...types.post_profile_response import PostProfileResponse
from ...types.profile_create_query_resource_object import ProfileCreateQueryResourceObject
from ...types.profile_partial_update_query_resource_object import ProfilePartialUpdateQueryResourceObject
from ...types.push_token_create_query import PushTokenCreateQuery
from ...types.subscription_create_job_create_query_resource_object import SubscriptionCreateJobCreateQueryResourceObject
from ...types.subscription_delete_job_create_query_resource_object import SubscriptionDeleteJobCreateQueryResourceObject
from ...types.suppression_create_job_create_query_resource_object import SuppressionCreateJobCreateQueryResourceObject
from ...types.suppression_delete_job_create_query_resource_object import SuppressionDeleteJobCreateQueryResourceObject

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProfilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_profiles(
        self,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_profile: typing.Union[
            typing.Optional[GetProfilesRequestFieldsProfileItem], typing.List[GetProfilesRequestFieldsProfileItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        sort: typing.Optional[GetProfilesRequestSort] = None,
    ) -> GetProfileResponseCollectionCompoundDocument:
        """
        Get all profiles in an account.

        Profiles can be sorted by the following fields in ascending and descending order: `id`, `created`, `updated`, `email`<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`<br><br>Rate limits when using the `additional-fields[profile]=predictive_analytics` parameter in your API request:<br>Burst: `10/s`<br>Steady: `150/m`<br><br>To learn more about how the `additional-fields` parameter impacts rate limits, check out our [Rate limits, status codes, and errors](https://developers.klaviyo.com/en/v2023-08-15/docs/rate_limits_and_error_handling) guide.

        **Scopes:**
        `profiles:read`

        Parameters:
            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_profile: typing.Union[typing.Optional[GetProfilesRequestFieldsProfileItem], typing.List[GetProfilesRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`id`: `any`, `equals`<br>`email`: `any`, `equals`<br>`phone_number`: `any`, `equals`<br>`external_id`: `any`, `equals`<br>`_kx`: `equals`<br>`created`: `greater-than`, `less-than`<br>`updated`: `greater-than`, `less-than`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - page_size: typing.Optional[int]. Default: 20. Min: 1. Max: 100.

            - sort: typing.Optional[GetProfilesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profiles"),
            params=remove_none_from_dict(
                {
                    "additional-fields[profile]": additional_fields_profile,
                    "fields[profile]": fields_profile,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "page[size]": page_size,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_profile(self, *, data: ProfileCreateQueryResourceObject) -> PostProfileResponse:
        """
        Create a new profile.

        If you use a phone number as the profile identifier and SMS is not set up in the Klaviyo account,
        you'll need to include at least one other identifier attribute (`email` or `external_id`)
        in addition to the `phone_number` attribute for the API call to work.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`

        Parameters:
            - data: ProfileCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profiles"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_profile(
        self,
        id: str,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_list: typing.Union[
            typing.Optional[GetProfileRequestFieldsListItem], typing.List[GetProfileRequestFieldsListItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetProfileRequestFieldsProfileItem], typing.List[GetProfileRequestFieldsProfileItem]
        ],
        fields_segment: typing.Union[
            typing.Optional[GetProfileRequestFieldsSegmentItem], typing.List[GetProfileRequestFieldsSegmentItem]
        ],
        include: typing.Union[typing.Optional[GetProfileRequestIncludeItem], typing.List[GetProfileRequestIncludeItem]],
    ) -> GetProfileResponseCompoundDocument:
        """
        Get the profile with the given profile ID.

        Include parameters can be provided to get the following related resource data: `lists` (memberships), `segments` (memberships)<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:read`

        Parameters:
            - id: str.

            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_list: typing.Union[typing.Optional[GetProfileRequestFieldsListItem], typing.List[GetProfileRequestFieldsListItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetProfileRequestFieldsProfileItem], typing.List[GetProfileRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_segment: typing.Union[typing.Optional[GetProfileRequestFieldsSegmentItem], typing.List[GetProfileRequestFieldsSegmentItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetProfileRequestIncludeItem], typing.List[GetProfileRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}"),
            params=remove_none_from_dict(
                {
                    "additional-fields[profile]": additional_fields_profile,
                    "fields[list]": fields_list,
                    "fields[profile]": fields_profile,
                    "fields[segment]": fields_segment,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_profile(self, id: str, *, data: ProfilePartialUpdateQueryResourceObject) -> PatchProfileResponse:
        """
        Update the profile with the given profile ID.

        If you use a phone number as the profile identifier and SMS is not set up in the Klaviyo account,
        you'll need to include at least one other identifier attribute (`email` or `external_id`)
        in addition to the `phone_number` attribute for the API call to work.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`

        Parameters:
            - id: str. Primary key that uniquely identifies this profile. Generated by Klaviyo.

            - data: ProfilePartialUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def suppress_profiles(self, *, data: SuppressionCreateJobCreateQueryResourceObject) -> None:
        """
        Manually suppress one or more profiles. Such profiles will have `USER_SUPPRESSED` as their suppression reason. Manually suppressed profiles _will not_ receive email marketing. Learn more about suppressed profiles [in this document](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).

        Not supported for SMS marketing.

        Maximum number of profile can be submitted for suppression: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SuppressionCreateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profile-suppression-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def unsuppress_profiles(self, *, data: SuppressionDeleteJobCreateQueryResourceObject) -> None:
        """
        Unsuppress one or more profiles, this will remove any Manual Suppressions (USER_SUPPRESSED) on these profiles. A profile may receive email marketing after a manual suppression is removed so long as they have not revoked consent, i.e. unsubscribed.

        Not supported for SMS marketing. Only manual suppressions (USER_SUPPRESSED) will be removed. `UNSUBSCRIBE` and `SPAM_REPORT` suppressions are removed whenever a [profile resubscribes](https://developers.klaviyo.com/en/reference/subscribe_profiles).
        `INVALID_EMAIL` and `HARD_BOUNCE` suppressions cannot be removed by the API.

        Maximum number of profile can be submitted for unsuppression: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `subscriptions:write`

        Parameters:
            - data: SuppressionDeleteJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profile-suppression-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def subscribe_profiles(self, *, data: SubscriptionCreateJobCreateQueryResourceObject) -> None:
        """
        Subscribe one or more profiles to email marketing, SMS marketing, or both. If the list has double opt-in enabled, profiles will receive a message requiring their confirmation before subscribing. Otherwise, profiles will be immediately subscribed without receiving a confirmation message.

        To add someone to a list without changing their subscription status, use [Add Profile to List](https://developers.klaviyo.com/en/reference/create_list_relationships).

        This API will remove any `UNSUBSCRIBE`, `SPAM_REPORT` or `USER_SUPPRESSED` suppressions from the provided profiles. Learn more about suppressed profiles in [this document](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).

        Maximum number of profile can be submitted for subscription: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `list:write`
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SubscriptionCreateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/profile-subscription-bulk-create-jobs"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def unsubscribe_profiles(self, *, data: SubscriptionDeleteJobCreateQueryResourceObject) -> None:
        """
        Unsubscribe one or more profiles to email marketing, SMS marketing, or both.

        To remove someone from a list without changing their subscription status, use [Remove Profile from List](https://developers.klaviyo.com/en/reference/delete_list_relationships).

        Maximum number of profile can be submitted for unsubscription: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `list:write`
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SubscriptionDeleteJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/profile-subscription-bulk-delete-jobs"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_push_token(self, *, request: PushTokenCreateQuery) -> None:
        """
        Create or update a push token.

        This endpoint can be used to migrate push tokens from another platform to Klaviyo. Please use our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)) to create push tokens from users' devices.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`
        `push-tokens:write`

        Parameters:
            - request: PushTokenCreateQuery.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/push-tokens"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_profile_lists(
        self,
        id: str,
        *,
        fields_list: typing.Union[
            typing.Optional[GetProfileListsRequestFieldsListItem], typing.List[GetProfileListsRequestFieldsListItem]
        ],
    ) -> GetListResponseCollection:
        """
        Get list memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `profiles:read`

        Parameters:
            - id: str.

            - fields_list: typing.Union[typing.Optional[GetProfileListsRequestFieldsListItem], typing.List[GetProfileListsRequestFieldsListItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/lists"),
            params=remove_none_from_dict({"fields[list]": fields_list}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_profile_relationships_lists(self, id: str) -> GetProfileListRelationshipsResponseCollection:
        """
        Get list memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `profiles:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/relationships/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileListRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_profile_segments(
        self,
        id: str,
        *,
        fields_segment: typing.Union[
            typing.Optional[GetProfileSegmentsRequestFieldsSegmentItem],
            typing.List[GetProfileSegmentsRequestFieldsSegmentItem],
        ],
    ) -> GetSegmentResponseCollection:
        """
        Get segment memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `profiles:read`
        `segments:read`

        Parameters:
            - id: str.

            - fields_segment: typing.Union[typing.Optional[GetProfileSegmentsRequestFieldsSegmentItem], typing.List[GetProfileSegmentsRequestFieldsSegmentItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/segments"),
            params=remove_none_from_dict({"fields[segment]": fields_segment}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetSegmentResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_profile_relationships_segments(self, id: str) -> GetProfileSegmentRelationshipsResponseCollection:
        """
        Get segment membership relationships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `profiles:read`
        `segments:read`

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/relationships/segments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileSegmentRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProfilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_profiles(
        self,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_profile: typing.Union[
            typing.Optional[GetProfilesRequestFieldsProfileItem], typing.List[GetProfilesRequestFieldsProfileItem]
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        sort: typing.Optional[GetProfilesRequestSort] = None,
    ) -> GetProfileResponseCollectionCompoundDocument:
        """
        Get all profiles in an account.

        Profiles can be sorted by the following fields in ascending and descending order: `id`, `created`, `updated`, `email`<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`<br><br>Rate limits when using the `additional-fields[profile]=predictive_analytics` parameter in your API request:<br>Burst: `10/s`<br>Steady: `150/m`<br><br>To learn more about how the `additional-fields` parameter impacts rate limits, check out our [Rate limits, status codes, and errors](https://developers.klaviyo.com/en/v2023-08-15/docs/rate_limits_and_error_handling) guide.

        **Scopes:**
        `profiles:read`

        Parameters:
            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_profile: typing.Union[typing.Optional[GetProfilesRequestFieldsProfileItem], typing.List[GetProfilesRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`id`: `any`, `equals`<br>`email`: `any`, `equals`<br>`phone_number`: `any`, `equals`<br>`external_id`: `any`, `equals`<br>`_kx`: `equals`<br>`created`: `greater-than`, `less-than`<br>`updated`: `greater-than`, `less-than`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - page_size: typing.Optional[int]. Default: 20. Min: 1. Max: 100.

            - sort: typing.Optional[GetProfilesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profiles"),
            params=remove_none_from_dict(
                {
                    "additional-fields[profile]": additional_fields_profile,
                    "fields[profile]": fields_profile,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "page[size]": page_size,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_profile(self, *, data: ProfileCreateQueryResourceObject) -> PostProfileResponse:
        """
        Create a new profile.

        If you use a phone number as the profile identifier and SMS is not set up in the Klaviyo account,
        you'll need to include at least one other identifier attribute (`email` or `external_id`)
        in addition to the `phone_number` attribute for the API call to work.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`

        Parameters:
            - data: ProfileCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profiles"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_profile(
        self,
        id: str,
        *,
        additional_fields_profile: typing.Union[
            typing.Optional[typing_extensions.Literal["predictive_analytics"]],
            typing.List[typing_extensions.Literal["predictive_analytics"]],
        ],
        fields_list: typing.Union[
            typing.Optional[GetProfileRequestFieldsListItem], typing.List[GetProfileRequestFieldsListItem]
        ],
        fields_profile: typing.Union[
            typing.Optional[GetProfileRequestFieldsProfileItem], typing.List[GetProfileRequestFieldsProfileItem]
        ],
        fields_segment: typing.Union[
            typing.Optional[GetProfileRequestFieldsSegmentItem], typing.List[GetProfileRequestFieldsSegmentItem]
        ],
        include: typing.Union[typing.Optional[GetProfileRequestIncludeItem], typing.List[GetProfileRequestIncludeItem]],
    ) -> GetProfileResponseCompoundDocument:
        """
        Get the profile with the given profile ID.

        Include parameters can be provided to get the following related resource data: `lists` (memberships), `segments` (memberships)<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:read`

        Parameters:
            - id: str.

            - additional_fields_profile: typing.Union[typing.Optional[typing_extensions.Literal["predictive_analytics"]], typing.List[typing_extensions.Literal["predictive_analytics"]]]. Request additional fields not included by default in the response. Supported values: 'predictive_analytics'

            - fields_list: typing.Union[typing.Optional[GetProfileRequestFieldsListItem], typing.List[GetProfileRequestFieldsListItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_profile: typing.Union[typing.Optional[GetProfileRequestFieldsProfileItem], typing.List[GetProfileRequestFieldsProfileItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_segment: typing.Union[typing.Optional[GetProfileRequestFieldsSegmentItem], typing.List[GetProfileRequestFieldsSegmentItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[GetProfileRequestIncludeItem], typing.List[GetProfileRequestIncludeItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}"),
            params=remove_none_from_dict(
                {
                    "additional-fields[profile]": additional_fields_profile,
                    "fields[list]": fields_list,
                    "fields[profile]": fields_profile,
                    "fields[segment]": fields_segment,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_profile(self, id: str, *, data: ProfilePartialUpdateQueryResourceObject) -> PatchProfileResponse:
        """
        Update the profile with the given profile ID.

        If you use a phone number as the profile identifier and SMS is not set up in the Klaviyo account,
        you'll need to include at least one other identifier attribute (`email` or `external_id`)
        in addition to the `phone_number` attribute for the API call to work.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`

        Parameters:
            - id: str. Primary key that uniquely identifies this profile. Generated by Klaviyo.

            - data: ProfilePartialUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchProfileResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def suppress_profiles(self, *, data: SuppressionCreateJobCreateQueryResourceObject) -> None:
        """
        Manually suppress one or more profiles. Such profiles will have `USER_SUPPRESSED` as their suppression reason. Manually suppressed profiles _will not_ receive email marketing. Learn more about suppressed profiles [in this document](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).

        Not supported for SMS marketing.

        Maximum number of profile can be submitted for suppression: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SuppressionCreateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profile-suppression-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def unsuppress_profiles(self, *, data: SuppressionDeleteJobCreateQueryResourceObject) -> None:
        """
        Unsuppress one or more profiles, this will remove any Manual Suppressions (USER_SUPPRESSED) on these profiles. A profile may receive email marketing after a manual suppression is removed so long as they have not revoked consent, i.e. unsubscribed.

        Not supported for SMS marketing. Only manual suppressions (USER_SUPPRESSED) will be removed. `UNSUBSCRIBE` and `SPAM_REPORT` suppressions are removed whenever a [profile resubscribes](https://developers.klaviyo.com/en/reference/subscribe_profiles).
        `INVALID_EMAIL` and `HARD_BOUNCE` suppressions cannot be removed by the API.

        Maximum number of profile can be submitted for unsuppression: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `subscriptions:write`

        Parameters:
            - data: SuppressionDeleteJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/profile-suppression-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def subscribe_profiles(self, *, data: SubscriptionCreateJobCreateQueryResourceObject) -> None:
        """
        Subscribe one or more profiles to email marketing, SMS marketing, or both. If the list has double opt-in enabled, profiles will receive a message requiring their confirmation before subscribing. Otherwise, profiles will be immediately subscribed without receiving a confirmation message.

        To add someone to a list without changing their subscription status, use [Add Profile to List](https://developers.klaviyo.com/en/reference/create_list_relationships).

        This API will remove any `UNSUBSCRIBE`, `SPAM_REPORT` or `USER_SUPPRESSED` suppressions from the provided profiles. Learn more about suppressed profiles in [this document](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).

        Maximum number of profile can be submitted for subscription: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `list:write`
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SubscriptionCreateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/profile-subscription-bulk-create-jobs"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def unsubscribe_profiles(self, *, data: SubscriptionDeleteJobCreateQueryResourceObject) -> None:
        """
        Unsubscribe one or more profiles to email marketing, SMS marketing, or both.

        To remove someone from a list without changing their subscription status, use [Remove Profile from List](https://developers.klaviyo.com/en/reference/delete_list_relationships).

        Maximum number of profile can be submitted for unsubscription: 100<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `list:write`
        `profiles:write`
        `subscriptions:write`

        Parameters:
            - data: SubscriptionDeleteJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/profile-subscription-bulk-delete-jobs"
            ),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_push_token(self, *, request: PushTokenCreateQuery) -> None:
        """
        Create or update a push token.

        This endpoint can be used to migrate push tokens from another platform to Klaviyo. Please use our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)) to create push tokens from users' devices.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `profiles:write`
        `push-tokens:write`

        Parameters:
            - request: PushTokenCreateQuery.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/push-tokens"),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_profile_lists(
        self,
        id: str,
        *,
        fields_list: typing.Union[
            typing.Optional[GetProfileListsRequestFieldsListItem], typing.List[GetProfileListsRequestFieldsListItem]
        ],
    ) -> GetListResponseCollection:
        """
        Get list memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `profiles:read`

        Parameters:
            - id: str.

            - fields_list: typing.Union[typing.Optional[GetProfileListsRequestFieldsListItem], typing.List[GetProfileListsRequestFieldsListItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/lists"),
            params=remove_none_from_dict({"fields[list]": fields_list}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_profile_relationships_lists(self, id: str) -> GetProfileListRelationshipsResponseCollection:
        """
        Get list memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `list:read`
        `profiles:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/relationships/lists"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileListRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_profile_segments(
        self,
        id: str,
        *,
        fields_segment: typing.Union[
            typing.Optional[GetProfileSegmentsRequestFieldsSegmentItem],
            typing.List[GetProfileSegmentsRequestFieldsSegmentItem],
        ],
    ) -> GetSegmentResponseCollection:
        """
        Get segment memberships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `profiles:read`
        `segments:read`

        Parameters:
            - id: str.

            - fields_segment: typing.Union[typing.Optional[GetProfileSegmentsRequestFieldsSegmentItem], typing.List[GetProfileSegmentsRequestFieldsSegmentItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/segments"),
            params=remove_none_from_dict({"fields[segment]": fields_segment}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetSegmentResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_profile_relationships_segments(self, id: str) -> GetProfileSegmentRelationshipsResponseCollection:
        """
        Get segment membership relationships for a profile with the given profile ID.<br><br>*Rate limits*:<br>Burst: `3/s`<br>Steady: `60/m`

        **Scopes:**
        `profiles:read`
        `segments:read`

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/profiles/{id}/relationships/segments"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetProfileSegmentRelationshipsResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
