# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...types.catalog_category_create_job_create_query_resource_object import (
    CatalogCategoryCreateJobCreateQueryResourceObject,
)
from ...types.catalog_category_create_query_resource_object import CatalogCategoryCreateQueryResourceObject
from ...types.catalog_category_delete_job_create_query_resource_object import (
    CatalogCategoryDeleteJobCreateQueryResourceObject,
)
from ...types.catalog_category_item_op import CatalogCategoryItemOp
from ...types.catalog_category_update_job_create_query_resource_object import (
    CatalogCategoryUpdateJobCreateQueryResourceObject,
)
from ...types.catalog_category_update_query_resource_object import CatalogCategoryUpdateQueryResourceObject
from ...types.catalog_item_category_op import CatalogItemCategoryOp
from ...types.catalog_item_create_job_create_query_resource_object import CatalogItemCreateJobCreateQueryResourceObject
from ...types.catalog_item_create_query_resource_object import CatalogItemCreateQueryResourceObject
from ...types.catalog_item_delete_job_create_query_resource_object import CatalogItemDeleteJobCreateQueryResourceObject
from ...types.catalog_item_update_job_create_query_resource_object import CatalogItemUpdateJobCreateQueryResourceObject
from ...types.catalog_item_update_query_resource_object import CatalogItemUpdateQueryResourceObject
from ...types.catalog_variant_create_job_create_query_resource_object import (
    CatalogVariantCreateJobCreateQueryResourceObject,
)
from ...types.catalog_variant_create_query_resource_object import CatalogVariantCreateQueryResourceObject
from ...types.catalog_variant_delete_job_create_query_resource_object import (
    CatalogVariantDeleteJobCreateQueryResourceObject,
)
from ...types.catalog_variant_update_job_create_query_resource_object import (
    CatalogVariantUpdateJobCreateQueryResourceObject,
)
from ...types.catalog_variant_update_query_resource_object import CatalogVariantUpdateQueryResourceObject
from ...types.get_catalog_categories_request_fields_catalog_category_item import (
    GetCatalogCategoriesRequestFieldsCatalogCategoryItem,
)
from ...types.get_catalog_categories_request_sort import GetCatalogCategoriesRequestSort
from ...types.get_catalog_category_create_job_response_collection_compound_document import (
    GetCatalogCategoryCreateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_category_create_job_response_compound_document import (
    GetCatalogCategoryCreateJobResponseCompoundDocument,
)
from ...types.get_catalog_category_delete_job_response import GetCatalogCategoryDeleteJobResponse
from ...types.get_catalog_category_delete_job_response_collection import GetCatalogCategoryDeleteJobResponseCollection
from ...types.get_catalog_category_item_list_response_collection import GetCatalogCategoryItemListResponseCollection
from ...types.get_catalog_category_items_request_fields_catalog_item_item import (
    GetCatalogCategoryItemsRequestFieldsCatalogItemItem,
)
from ...types.get_catalog_category_items_request_fields_catalog_variant_item import (
    GetCatalogCategoryItemsRequestFieldsCatalogVariantItem,
)
from ...types.get_catalog_category_items_request_sort import GetCatalogCategoryItemsRequestSort
from ...types.get_catalog_category_request_fields_catalog_category_item import (
    GetCatalogCategoryRequestFieldsCatalogCategoryItem,
)
from ...types.get_catalog_category_response import GetCatalogCategoryResponse
from ...types.get_catalog_category_response_collection import GetCatalogCategoryResponseCollection
from ...types.get_catalog_category_update_job_response_collection_compound_document import (
    GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_category_update_job_response_compound_document import (
    GetCatalogCategoryUpdateJobResponseCompoundDocument,
)
from ...types.get_catalog_item_categories_request_fields_catalog_category_item import (
    GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem,
)
from ...types.get_catalog_item_categories_request_sort import GetCatalogItemCategoriesRequestSort
from ...types.get_catalog_item_category_list_response_collection import GetCatalogItemCategoryListResponseCollection
from ...types.get_catalog_item_create_job_response_collection_compound_document import (
    GetCatalogItemCreateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_item_create_job_response_compound_document import (
    GetCatalogItemCreateJobResponseCompoundDocument,
)
from ...types.get_catalog_item_delete_job_response import GetCatalogItemDeleteJobResponse
from ...types.get_catalog_item_delete_job_response_collection import GetCatalogItemDeleteJobResponseCollection
from ...types.get_catalog_item_request_fields_catalog_item_item import GetCatalogItemRequestFieldsCatalogItemItem
from ...types.get_catalog_item_request_fields_catalog_variant_item import GetCatalogItemRequestFieldsCatalogVariantItem
from ...types.get_catalog_item_response_collection_compound_document import (
    GetCatalogItemResponseCollectionCompoundDocument,
)
from ...types.get_catalog_item_response_compound_document import GetCatalogItemResponseCompoundDocument
from ...types.get_catalog_item_update_job_response_collection_compound_document import (
    GetCatalogItemUpdateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_item_update_job_response_compound_document import (
    GetCatalogItemUpdateJobResponseCompoundDocument,
)
from ...types.get_catalog_item_variants_request_fields_catalog_variant_item import (
    GetCatalogItemVariantsRequestFieldsCatalogVariantItem,
)
from ...types.get_catalog_item_variants_request_sort import GetCatalogItemVariantsRequestSort
from ...types.get_catalog_items_request_fields_catalog_item_item import GetCatalogItemsRequestFieldsCatalogItemItem
from ...types.get_catalog_items_request_fields_catalog_variant_item import (
    GetCatalogItemsRequestFieldsCatalogVariantItem,
)
from ...types.get_catalog_items_request_sort import GetCatalogItemsRequestSort
from ...types.get_catalog_variant_create_job_response_collection_compound_document import (
    GetCatalogVariantCreateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_variant_create_job_response_compound_document import (
    GetCatalogVariantCreateJobResponseCompoundDocument,
)
from ...types.get_catalog_variant_delete_job_response import GetCatalogVariantDeleteJobResponse
from ...types.get_catalog_variant_delete_job_response_collection import GetCatalogVariantDeleteJobResponseCollection
from ...types.get_catalog_variant_request_fields_catalog_variant_item import (
    GetCatalogVariantRequestFieldsCatalogVariantItem,
)
from ...types.get_catalog_variant_response import GetCatalogVariantResponse
from ...types.get_catalog_variant_response_collection import GetCatalogVariantResponseCollection
from ...types.get_catalog_variant_update_job_response_collection_compound_document import (
    GetCatalogVariantUpdateJobResponseCollectionCompoundDocument,
)
from ...types.get_catalog_variant_update_job_response_compound_document import (
    GetCatalogVariantUpdateJobResponseCompoundDocument,
)
from ...types.get_catalog_variants_request_fields_catalog_variant_item import (
    GetCatalogVariantsRequestFieldsCatalogVariantItem,
)
from ...types.get_catalog_variants_request_sort import GetCatalogVariantsRequestSort
from ...types.get_create_categories_job_request_fields_catalog_category_bulk_create_job_item import (
    GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem,
)
from ...types.get_create_categories_job_request_fields_catalog_category_item import (
    GetCreateCategoriesJobRequestFieldsCatalogCategoryItem,
)
from ...types.get_create_categories_jobs_request_fields_catalog_category_bulk_create_job_item import (
    GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem,
)
from ...types.get_create_items_job_request_fields_catalog_item_bulk_create_job_item import (
    GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem,
)
from ...types.get_create_items_job_request_fields_catalog_item_item import GetCreateItemsJobRequestFieldsCatalogItemItem
from ...types.get_create_items_jobs_request_fields_catalog_item_bulk_create_job_item import (
    GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem,
)
from ...types.get_create_variants_job_request_fields_catalog_variant_bulk_create_job_item import (
    GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem,
)
from ...types.get_create_variants_job_request_fields_catalog_variant_item import (
    GetCreateVariantsJobRequestFieldsCatalogVariantItem,
)
from ...types.get_create_variants_jobs_request_fields_catalog_variant_bulk_create_job_item import (
    GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem,
)
from ...types.get_delete_categories_job_request_fields_catalog_category_bulk_delete_job_item import (
    GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem,
)
from ...types.get_delete_categories_jobs_request_fields_catalog_category_bulk_delete_job_item import (
    GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem,
)
from ...types.get_delete_items_job_request_fields_catalog_item_bulk_delete_job_item import (
    GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem,
)
from ...types.get_delete_items_jobs_request_fields_catalog_item_bulk_delete_job_item import (
    GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem,
)
from ...types.get_delete_variants_job_request_fields_catalog_variant_bulk_delete_job_item import (
    GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem,
)
from ...types.get_delete_variants_jobs_request_fields_catalog_variant_bulk_delete_job_item import (
    GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem,
)
from ...types.get_update_categories_job_request_fields_catalog_category_bulk_update_job_item import (
    GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem,
)
from ...types.get_update_categories_job_request_fields_catalog_category_item import (
    GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem,
)
from ...types.get_update_categories_jobs_request_fields_catalog_category_bulk_update_job_item import (
    GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem,
)
from ...types.get_update_items_job_request_fields_catalog_item_bulk_update_job_item import (
    GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem,
)
from ...types.get_update_items_job_request_fields_catalog_item_item import GetUpdateItemsJobRequestFieldsCatalogItemItem
from ...types.get_update_items_jobs_request_fields_catalog_item_bulk_update_job_item import (
    GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem,
)
from ...types.get_update_variants_job_request_fields_catalog_variant_bulk_update_job_item import (
    GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem,
)
from ...types.get_update_variants_job_request_fields_catalog_variant_item import (
    GetUpdateVariantsJobRequestFieldsCatalogVariantItem,
)
from ...types.get_update_variants_jobs_request_fields_catalog_variant_bulk_update_job_item import (
    GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem,
)
from ...types.patch_catalog_category_response import PatchCatalogCategoryResponse
from ...types.patch_catalog_item_response import PatchCatalogItemResponse
from ...types.patch_catalog_variant_response import PatchCatalogVariantResponse
from ...types.post_catalog_category_response import PostCatalogCategoryResponse
from ...types.post_catalog_item_response import PostCatalogItemResponse
from ...types.post_catalog_variant_response import PostCatalogVariantResponse
from ...types.server_bis_subscription_create_query_resource_object import ServerBisSubscriptionCreateQueryResourceObject

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CatalogsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_catalog_items(
        self,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogItemsRequestFieldsCatalogItemItem],
            typing.List[GetCatalogItemsRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemsRequestSort] = None,
    ) -> GetCatalogItemResponseCollectionCompoundDocument:
        """
        Get all catalog items in an account.

        Catalog items can be sorted by the following fields, in ascending and descending order:
        `created`

        Include parameters can be provided to get the following related resource data: `variants`

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogItemsRequestFieldsCatalogItemItem], typing.List[GetCatalogItemsRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemsRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`category.id`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-items"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_catalog_item(self, *, data: CatalogItemCreateQueryResourceObject) -> PostCatalogItemResponse:
        """
        Create a new catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-items"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogItemResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_item(
        self,
        id: str,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogItemRequestFieldsCatalogItemItem],
            typing.List[GetCatalogItemRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogItemResponseCompoundDocument:
        """
        Get a specific catalog item with the given item ID.

        Include parameters can be provided to get the following related resource data: `variants`<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogItemRequestFieldsCatalogItemItem], typing.List[GetCatalogItemRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_catalog_item(self, id: str, *, data: CatalogItemUpdateQueryResourceObject) -> PatchCatalogItemResponse:
        """
        Update a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogItemUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogItemResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_catalog_item(self, id: str) -> None:
        """
        Delete a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_variants(
        self,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogVariantsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogVariantsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogVariantsRequestSort] = None,
    ) -> GetCatalogVariantResponseCollection:
        """
        Get all variants in an account.

        Variants can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogVariantsRequestFieldsCatalogVariantItem], typing.List[GetCatalogVariantsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`sku`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogVariantsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variants"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_catalog_variant(self, *, data: CatalogVariantCreateQueryResourceObject) -> PostCatalogVariantResponse:
        """
        Create a new variant for a related catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variants"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_variant(
        self,
        id: str,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogVariantRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogVariantRequestFieldsCatalogVariantItem],
        ],
    ) -> GetCatalogVariantResponse:
        """
        Get a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogVariantRequestFieldsCatalogVariantItem], typing.List[GetCatalogVariantRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            params=remove_none_from_dict({"fields[catalog-variant]": fields_catalog_variant}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_catalog_variant(
        self, id: str, *, data: CatalogVariantUpdateQueryResourceObject
    ) -> PatchCatalogVariantResponse:
        """
        Update a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogVariantUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_catalog_variant(self, id: str) -> None:
        """
        Delete a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_categories(
        self,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogCategoriesRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogCategoriesRequestFieldsCatalogCategoryItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogCategoriesRequestSort] = None,
    ) -> GetCatalogCategoryResponseCollection:
        """
        Get all catalog categories in an account.

        Catalog categories can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogCategoriesRequestFieldsCatalogCategoryItem], typing.List[GetCatalogCategoriesRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`name`: `contains`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogCategoriesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-categories"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category]": fields_catalog_category,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_catalog_category(self, *, data: CatalogCategoryCreateQueryResourceObject) -> PostCatalogCategoryResponse:
        """
        Create a new catalog category.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-categories"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_category(
        self,
        id: str,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogCategoryRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogCategoryRequestFieldsCatalogCategoryItem],
        ],
    ) -> GetCatalogCategoryResponse:
        """
        Get a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogCategoryRequestFieldsCatalogCategoryItem], typing.List[GetCatalogCategoryRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            params=remove_none_from_dict({"fields[catalog-category]": fields_catalog_category}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_catalog_category(
        self, id: str, *, data: CatalogCategoryUpdateQueryResourceObject
    ) -> PatchCatalogCategoryResponse:
        """
        Update a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogCategoryUpdateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_catalog_category(self, id: str) -> None:
        """
        Delete a catalog category using the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_create_job: typing.Union[
            typing.Optional[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem],
            typing.List[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog item bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_create_job: typing.Union[typing.Optional[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem], typing.List[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-create-job]": fields_catalog_item_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_create_items_job(self, *, data: CatalogItemCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk create job to create a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemCreateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_create_job: typing.Union[
            typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem],
            typing.List[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem],
        ],
        fields_catalog_item: typing.Union[
            typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemItem],
            typing.List[GetCreateItemsJobRequestFieldsCatalogItemItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]
        ],
    ) -> GetCatalogItemCreateJobResponseCompoundDocument:
        """
        Get a catalog item bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_create_job: typing.Union[typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem], typing.List[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_item: typing.Union[typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemItem], typing.List[GetCreateItemsJobRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-create-job]": fields_catalog_item_bulk_create_job,
                    "fields[catalog-item]": fields_catalog_item,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem],
            typing.List[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog item bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_update_job: typing.Union[typing.Optional[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem], typing.List[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-update-job]": fields_catalog_item_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_update_items_job(self, *, data: CatalogItemUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk update job to update a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemUpdateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem],
            typing.List[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem],
        ],
        fields_catalog_item: typing.Union[
            typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemItem],
            typing.List[GetUpdateItemsJobRequestFieldsCatalogItemItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]
        ],
    ) -> GetCatalogItemUpdateJobResponseCompoundDocument:
        """
        Get a catalog item bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_update_job: typing.Union[typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem], typing.List[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_item: typing.Union[typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemItem], typing.List[GetUpdateItemsJobRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-update-job]": fields_catalog_item_bulk_update_job,
                    "fields[catalog-item]": fields_catalog_item,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem],
            typing.List[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemDeleteJobResponseCollection:
        """
        Get all catalog item bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_delete_job: typing.Union[typing.Optional[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem], typing.List[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-delete-job]": fields_catalog_item_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_delete_items_job(self, *, data: CatalogItemDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk delete job to delete a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemDeleteJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem],
            typing.List[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem],
        ],
    ) -> GetCatalogItemDeleteJobResponse:
        """
        Get a catalog item bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_delete_job: typing.Union[typing.Optional[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem], typing.List[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict({"fields[catalog-item-bulk-delete-job]": fields_catalog_item_bulk_delete_job}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_create_job: typing.Union[
            typing.Optional[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem],
            typing.List[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog variant bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_create_job: typing.Union[typing.Optional[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem], typing.List[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-create-job]": fields_catalog_variant_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_create_variants_job(self, *, data: CatalogVariantCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk create job to create a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantCreateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_create_job: typing.Union[
            typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem],
            typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantItem],
            typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogVariantCreateJobResponseCompoundDocument:
        """
        Get a catalog variant bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_create_job: typing.Union[typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem], typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantItem], typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-create-job]": fields_catalog_variant_bulk_create_job,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem],
            typing.List[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog variant bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_update_job: typing.Union[typing.Optional[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem], typing.List[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-update-job]": fields_catalog_variant_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_update_variants_job(self, *, data: CatalogVariantUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk update job to update a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantUpdateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem],
            typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantItem],
            typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogVariantUpdateJobResponseCompoundDocument:
        """
        Get a catalog variate bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_update_job: typing.Union[typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem], typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantItem], typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-update-job]": fields_catalog_variant_bulk_update_job,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem],
            typing.List[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantDeleteJobResponseCollection:
        """
        Get all catalog variant bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_delete_job: typing.Union[typing.Optional[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem], typing.List[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-delete-job]": fields_catalog_variant_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_delete_variants_job(self, *, data: CatalogVariantDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk delete job to delete a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantDeleteJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem],
            typing.List[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem],
        ],
    ) -> GetCatalogVariantDeleteJobResponse:
        """
        Get a catalog variant bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_delete_job: typing.Union[typing.Optional[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem], typing.List[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {"fields[catalog-variant-bulk-delete-job]": fields_catalog_variant_bulk_delete_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_create_job: typing.Union[
            typing.Optional[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem],
            typing.List[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog category bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_create_job: typing.Union[typing.Optional[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem], typing.List[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-create-job]": fields_catalog_category_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_create_categories_job(self, *, data: CatalogCategoryCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk create job to create a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryCreateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_create_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_create_job: typing.Union[
            typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem],
            typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem],
        ],
        fields_catalog_category: typing.Union[
            typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem],
            typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["categories"]],
            typing.List[typing_extensions.Literal["categories"]],
        ],
    ) -> GetCatalogCategoryCreateJobResponseCompoundDocument:
        """
        Get a catalog category bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_create_job: typing.Union[typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem], typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_category: typing.Union[typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem], typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["categories"]], typing.List[typing_extensions.Literal["categories"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-create-job]": fields_catalog_category_bulk_create_job,
                    "fields[catalog-category]": fields_catalog_category,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem],
            typing.List[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog category bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_update_job: typing.Union[typing.Optional[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem], typing.List[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-update-job]": fields_catalog_category_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_update_categories_job(self, *, data: CatalogCategoryUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk update job to update a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryUpdateJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_update_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem],
            typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem],
        ],
        fields_catalog_category: typing.Union[
            typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem],
            typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["categories"]],
            typing.List[typing_extensions.Literal["categories"]],
        ],
    ) -> GetCatalogCategoryUpdateJobResponseCompoundDocument:
        """
        Get a catalog category bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_update_job: typing.Union[typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem], typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_category: typing.Union[typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem], typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["categories"]], typing.List[typing_extensions.Literal["categories"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-update-job]": fields_catalog_category_bulk_update_job,
                    "fields[catalog-category]": fields_catalog_category,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem],
            typing.List[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryDeleteJobResponseCollection:
        """
        Get all catalog category bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_delete_job: typing.Union[typing.Optional[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem], typing.List[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-delete-job]": fields_catalog_category_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def spawn_delete_categories_job(self, *, data: CatalogCategoryDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk delete job to delete a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryDeleteJobCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_delete_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem],
            typing.List[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem],
        ],
    ) -> GetCatalogCategoryDeleteJobResponse:
        """
        Get a catalog category bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_delete_job: typing.Union[typing.Optional[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem], typing.List[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {"fields[catalog-category-bulk-delete-job]": fields_catalog_category_bulk_delete_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_back_in_stock_subscription(self, *, data: ServerBisSubscriptionCreateQueryResourceObject) -> None:
        """
        Subscribe a profile to receive back in stock notifications. Check out [our Back in Stock API guide](https://developers.klaviyo.com/en/docs/how_to_set_up_custom_back_in_stock) for more details.

        This endpoint is specifically designed to be called from server-side applications. To create subscriptions from client-side contexts, use [POST /client/back-in-stock-subscriptions](https://developers.klaviyo.com/en/reference/create_client_back_in_stock_subscription).<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:write`
        `profiles:write`

        Parameters:
            - data: ServerBisSubscriptionCreateQueryResourceObject.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/back-in-stock-subscriptions"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_category_items(
        self,
        id: str,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogItemItem],
            typing.List[GetCatalogCategoryItemsRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogCategoryItemsRequestSort] = None,
    ) -> GetCatalogItemResponseCollectionCompoundDocument:
        """
        Get all items in a category with the given category ID.

        Items can be sorted by the following fields, in ascending and descending order:
        `created`

        Include parameters can be provided to get the following related resource data: `variants`

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogItemItem], typing.List[GetCatalogCategoryItemsRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem], typing.List[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`category.id`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogCategoryItemsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/items"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_item_variants(
        self,
        id: str,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemVariantsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemVariantsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemVariantsRequestSort] = None,
    ) -> GetCatalogVariantResponseCollection:
        """
        Get all variants related to the given item ID.

        Variants can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemVariantsRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemVariantsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`sku`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemVariantsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/variants"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_item_categories(
        self,
        id: str,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemCategoriesRequestSort] = None,
    ) -> GetCatalogCategoryResponseCollection:
        """
        Get all catalog categories that an item with the given item ID is in.

        Catalog categories can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem], typing.List[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`name`: `contains`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemCategoriesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/categories"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category]": fields_catalog_category,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_category_relationships_items(
        self, id: str, *, page_cursor: typing.Optional[str] = None
    ) -> GetCatalogCategoryItemListResponseCollection:
        """
        Get all items in the given category ID.

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            params=remove_none_from_dict({"page[cursor]": page_cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryItemListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Create a new item relationship for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Update item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Delete item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_catalog_item_relationships_categories(
        self, id: str, *, page_cursor: typing.Optional[str] = None
    ) -> GetCatalogItemCategoryListResponseCollection:
        """
        Get all catalog categories that a particular item is in.

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            params=remove_none_from_dict({"page[cursor]": page_cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCategoryListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Create a new catalog category relationship for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Update catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Delete catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCatalogsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_catalog_items(
        self,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogItemsRequestFieldsCatalogItemItem],
            typing.List[GetCatalogItemsRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemsRequestSort] = None,
    ) -> GetCatalogItemResponseCollectionCompoundDocument:
        """
        Get all catalog items in an account.

        Catalog items can be sorted by the following fields, in ascending and descending order:
        `created`

        Include parameters can be provided to get the following related resource data: `variants`

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogItemsRequestFieldsCatalogItemItem], typing.List[GetCatalogItemsRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemsRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`category.id`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-items"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_catalog_item(self, *, data: CatalogItemCreateQueryResourceObject) -> PostCatalogItemResponse:
        """
        Create a new catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-items"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogItemResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_item(
        self,
        id: str,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogItemRequestFieldsCatalogItemItem],
            typing.List[GetCatalogItemRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogItemResponseCompoundDocument:
        """
        Get a specific catalog item with the given item ID.

        Include parameters can be provided to get the following related resource data: `variants`<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogItemRequestFieldsCatalogItemItem], typing.List[GetCatalogItemRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_catalog_item(
        self, id: str, *, data: CatalogItemUpdateQueryResourceObject
    ) -> PatchCatalogItemResponse:
        """
        Update a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogItemUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogItemResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_catalog_item(self, id: str) -> None:
        """
        Delete a catalog item with the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog item ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_variants(
        self,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogVariantsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogVariantsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogVariantsRequestSort] = None,
    ) -> GetCatalogVariantResponseCollection:
        """
        Get all variants in an account.

        Variants can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogVariantsRequestFieldsCatalogVariantItem], typing.List[GetCatalogVariantsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`sku`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogVariantsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variants"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_catalog_variant(
        self, *, data: CatalogVariantCreateQueryResourceObject
    ) -> PostCatalogVariantResponse:
        """
        Create a new variant for a related catalog item.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variants"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_variant(
        self,
        id: str,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogVariantRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogVariantRequestFieldsCatalogVariantItem],
        ],
    ) -> GetCatalogVariantResponse:
        """
        Get a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogVariantRequestFieldsCatalogVariantItem], typing.List[GetCatalogVariantRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            params=remove_none_from_dict({"fields[catalog-variant]": fields_catalog_variant}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_catalog_variant(
        self, id: str, *, data: CatalogVariantUpdateQueryResourceObject
    ) -> PatchCatalogVariantResponse:
        """
        Update a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogVariantUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogVariantResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_catalog_variant(self, id: str) -> None:
        """
        Delete a catalog item variant with the given variant ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog variant ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variants/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_categories(
        self,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogCategoriesRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogCategoriesRequestFieldsCatalogCategoryItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogCategoriesRequestSort] = None,
    ) -> GetCatalogCategoryResponseCollection:
        """
        Get all catalog categories in an account.

        Catalog categories can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogCategoriesRequestFieldsCatalogCategoryItem], typing.List[GetCatalogCategoriesRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`name`: `contains`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogCategoriesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-categories"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category]": fields_catalog_category,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_catalog_category(
        self, *, data: CatalogCategoryCreateQueryResourceObject
    ) -> PostCatalogCategoryResponse:
        """
        Create a new catalog category.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-categories"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_category(
        self,
        id: str,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogCategoryRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogCategoryRequestFieldsCatalogCategoryItem],
        ],
    ) -> GetCatalogCategoryResponse:
        """
        Get a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogCategoryRequestFieldsCatalogCategoryItem], typing.List[GetCatalogCategoryRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            params=remove_none_from_dict({"fields[catalog-category]": fields_catalog_category}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_catalog_category(
        self, id: str, *, data: CatalogCategoryUpdateQueryResourceObject
    ) -> PatchCatalogCategoryResponse:
        """
        Update a catalog category with the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.

            - data: CatalogCategoryUpdateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PatchCatalogCategoryResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_catalog_category(self, id: str) -> None:
        """
        Delete a catalog category using the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str. The catalog category ID is a compound ID (string), with format: `{integration}:::{catalog}:::{external_id}`. Currently, the only supported integration type is `$custom`, and the only supported catalog is `$default`.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_create_job: typing.Union[
            typing.Optional[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem],
            typing.List[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog item bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_create_job: typing.Union[typing.Optional[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem], typing.List[GetCreateItemsJobsRequestFieldsCatalogItemBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-create-job]": fields_catalog_item_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_create_items_job(self, *, data: CatalogItemCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk create job to create a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemCreateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_create_job: typing.Union[
            typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem],
            typing.List[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem],
        ],
        fields_catalog_item: typing.Union[
            typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemItem],
            typing.List[GetCreateItemsJobRequestFieldsCatalogItemItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]
        ],
    ) -> GetCatalogItemCreateJobResponseCompoundDocument:
        """
        Get a catalog item bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_create_job: typing.Union[typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem], typing.List[GetCreateItemsJobRequestFieldsCatalogItemBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_item: typing.Union[typing.Optional[GetCreateItemsJobRequestFieldsCatalogItemItem], typing.List[GetCreateItemsJobRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-create-job]": fields_catalog_item_bulk_create_job,
                    "fields[catalog-item]": fields_catalog_item,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem],
            typing.List[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog item bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_update_job: typing.Union[typing.Optional[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem], typing.List[GetUpdateItemsJobsRequestFieldsCatalogItemBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-update-job]": fields_catalog_item_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_update_items_job(self, *, data: CatalogItemUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk update job to update a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemUpdateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem],
            typing.List[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem],
        ],
        fields_catalog_item: typing.Union[
            typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemItem],
            typing.List[GetUpdateItemsJobRequestFieldsCatalogItemItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]
        ],
    ) -> GetCatalogItemUpdateJobResponseCompoundDocument:
        """
        Get a catalog item bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `items`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_update_job: typing.Union[typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem], typing.List[GetUpdateItemsJobRequestFieldsCatalogItemBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_item: typing.Union[typing.Optional[GetUpdateItemsJobRequestFieldsCatalogItemItem], typing.List[GetUpdateItemsJobRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["items"]], typing.List[typing_extensions.Literal["items"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-update-job]": fields_catalog_item_bulk_update_job,
                    "fields[catalog-item]": fields_catalog_item,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_items_jobs(
        self,
        *,
        fields_catalog_item_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem],
            typing.List[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogItemDeleteJobResponseCollection:
        """
        Get all catalog item bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_item_bulk_delete_job: typing.Union[typing.Optional[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem], typing.List[GetDeleteItemsJobsRequestFieldsCatalogItemBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item-bulk-delete-job]": fields_catalog_item_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_delete_items_job(self, *, data: CatalogItemDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog item bulk delete job to delete a batch of catalog items.

        Accepts up to 100 catalog items per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogItemDeleteJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-item-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_items_job(
        self,
        job_id: str,
        *,
        fields_catalog_item_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem],
            typing.List[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem],
        ],
    ) -> GetCatalogItemDeleteJobResponse:
        """
        Get a catalog item bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_item_bulk_delete_job: typing.Union[typing.Optional[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem], typing.List[GetDeleteItemsJobRequestFieldsCatalogItemBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-item-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict({"fields[catalog-item-bulk-delete-job]": fields_catalog_item_bulk_delete_job}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_create_job: typing.Union[
            typing.Optional[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem],
            typing.List[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog variant bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_create_job: typing.Union[typing.Optional[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem], typing.List[GetCreateVariantsJobsRequestFieldsCatalogVariantBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-create-job]": fields_catalog_variant_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_create_variants_job(self, *, data: CatalogVariantCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk create job to create a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantCreateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_create_job: typing.Union[
            typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem],
            typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantItem],
            typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogVariantCreateJobResponseCompoundDocument:
        """
        Get a catalog variant bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_create_job: typing.Union[typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem], typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCreateVariantsJobRequestFieldsCatalogVariantItem], typing.List[GetCreateVariantsJobRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-create-job]": fields_catalog_variant_bulk_create_job,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem],
            typing.List[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog variant bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_update_job: typing.Union[typing.Optional[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem], typing.List[GetUpdateVariantsJobsRequestFieldsCatalogVariantBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-update-job]": fields_catalog_variant_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_update_variants_job(self, *, data: CatalogVariantUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk update job to update a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantUpdateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem],
            typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantItem],
            typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
    ) -> GetCatalogVariantUpdateJobResponseCompoundDocument:
        """
        Get a catalog variate bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `variants`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_update_job: typing.Union[typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem], typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetUpdateVariantsJobRequestFieldsCatalogVariantItem], typing.List[GetUpdateVariantsJobRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-update-job]": fields_catalog_variant_bulk_update_job,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_variants_jobs(
        self,
        *,
        fields_catalog_variant_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem],
            typing.List[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogVariantDeleteJobResponseCollection:
        """
        Get all catalog variant bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_variant_bulk_delete_job: typing.Union[typing.Optional[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem], typing.List[GetDeleteVariantsJobsRequestFieldsCatalogVariantBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant-bulk-delete-job]": fields_catalog_variant_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_delete_variants_job(self, *, data: CatalogVariantDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog variant bulk delete job to delete a batch of catalog variants.

        Accepts up to 100 catalog variants per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogVariantDeleteJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-variant-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_variants_job(
        self,
        job_id: str,
        *,
        fields_catalog_variant_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem],
            typing.List[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem],
        ],
    ) -> GetCatalogVariantDeleteJobResponse:
        """
        Get a catalog variant bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_variant_bulk_delete_job: typing.Union[typing.Optional[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem], typing.List[GetDeleteVariantsJobRequestFieldsCatalogVariantBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-variant-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {"fields[catalog-variant-bulk-delete-job]": fields_catalog_variant_bulk_delete_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_create_job: typing.Union[
            typing.Optional[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem],
            typing.List[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryCreateJobResponseCollectionCompoundDocument:
        """
        Get all catalog category bulk create jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_create_job: typing.Union[typing.Optional[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem], typing.List[GetCreateCategoriesJobsRequestFieldsCatalogCategoryBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-create-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-create-job]": fields_catalog_category_bulk_create_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryCreateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_create_categories_job(self, *, data: CatalogCategoryCreateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk create job to create a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryCreateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-create-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_create_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_create_job: typing.Union[
            typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem],
            typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem],
        ],
        fields_catalog_category: typing.Union[
            typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem],
            typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["categories"]],
            typing.List[typing_extensions.Literal["categories"]],
        ],
    ) -> GetCatalogCategoryCreateJobResponseCompoundDocument:
        """
        Get a catalog category bulk create job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_create_job: typing.Union[typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem], typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryBulkCreateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_category: typing.Union[typing.Optional[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem], typing.List[GetCreateCategoriesJobRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["categories"]], typing.List[typing_extensions.Literal["categories"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-create-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-create-job]": fields_catalog_category_bulk_create_job,
                    "fields[catalog-category]": fields_catalog_category,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryCreateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem],
            typing.List[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument:
        """
        Get all catalog category bulk update jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_update_job: typing.Union[typing.Optional[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem], typing.List[GetUpdateCategoriesJobsRequestFieldsCatalogCategoryBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-update-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-update-job]": fields_catalog_category_bulk_update_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryUpdateJobResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_update_categories_job(self, *, data: CatalogCategoryUpdateJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk update job to update a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryUpdateJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-update-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_update_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_update_job: typing.Union[
            typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem],
            typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem],
        ],
        fields_catalog_category: typing.Union[
            typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem],
            typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem],
        ],
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["categories"]],
            typing.List[typing_extensions.Literal["categories"]],
        ],
    ) -> GetCatalogCategoryUpdateJobResponseCompoundDocument:
        """
        Get a catalog category bulk update job with the given job ID.

        An `include` parameter can be provided to get the following related resource data: `categories`.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_update_job: typing.Union[typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem], typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryBulkUpdateJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_category: typing.Union[typing.Optional[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem], typing.List[GetUpdateCategoriesJobRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - include: typing.Union[typing.Optional[typing_extensions.Literal["categories"]], typing.List[typing_extensions.Literal["categories"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-update-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-update-job]": fields_catalog_category_bulk_update_job,
                    "fields[catalog-category]": fields_catalog_category,
                    "include": include,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryUpdateJobResponseCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_categories_jobs(
        self,
        *,
        fields_catalog_category_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem],
            typing.List[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
    ) -> GetCatalogCategoryDeleteJobResponseCollection:
        """
        Get all catalog category bulk delete jobs.

        Returns a maximum of 100 jobs per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - fields_catalog_category_bulk_delete_job: typing.Union[typing.Optional[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem], typing.List[GetDeleteCategoriesJobsRequestFieldsCatalogCategoryBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`status`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-delete-jobs"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category-bulk-delete-job]": fields_catalog_category_bulk_delete_job,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryDeleteJobResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def spawn_delete_categories_job(self, *, data: CatalogCategoryDeleteJobCreateQueryResourceObject) -> None:
        """
        Create a catalog category bulk delete job to delete a batch of catalog categories.

        Accepts up to 100 catalog categories per request. The maximum allowed payload size is 4MB.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - data: CatalogCategoryDeleteJobCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/catalog-category-bulk-delete-jobs"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_delete_categories_job(
        self,
        job_id: str,
        *,
        fields_catalog_category_bulk_delete_job: typing.Union[
            typing.Optional[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem],
            typing.List[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem],
        ],
    ) -> GetCatalogCategoryDeleteJobResponse:
        """
        Get a catalog category bulk delete job with the given job ID.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - job_id: str. ID of the job to retrieve.

            - fields_catalog_category_bulk_delete_job: typing.Union[typing.Optional[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem], typing.List[GetDeleteCategoriesJobRequestFieldsCatalogCategoryBulkDeleteJobItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-category-bulk-delete-jobs/{job_id}"
            ),
            params=remove_none_from_dict(
                {"fields[catalog-category-bulk-delete-job]": fields_catalog_category_bulk_delete_job}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryDeleteJobResponse, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_back_in_stock_subscription(self, *, data: ServerBisSubscriptionCreateQueryResourceObject) -> None:
        """
        Subscribe a profile to receive back in stock notifications. Check out [our Back in Stock API guide](https://developers.klaviyo.com/en/docs/how_to_set_up_custom_back_in_stock) for more details.

        This endpoint is specifically designed to be called from server-side applications. To create subscriptions from client-side contexts, use [POST /client/back-in-stock-subscriptions](https://developers.klaviyo.com/en/reference/create_client_back_in_stock_subscription).<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:write`
        `profiles:write`

        Parameters:
            - data: ServerBisSubscriptionCreateQueryResourceObject.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/back-in-stock-subscriptions"),
            json=jsonable_encoder({"data": data}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_category_items(
        self,
        id: str,
        *,
        fields_catalog_item: typing.Union[
            typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogItemItem],
            typing.List[GetCatalogCategoryItemsRequestFieldsCatalogItemItem],
        ],
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        include: typing.Union[
            typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]
        ],
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogCategoryItemsRequestSort] = None,
    ) -> GetCatalogItemResponseCollectionCompoundDocument:
        """
        Get all items in a category with the given category ID.

        Items can be sorted by the following fields, in ascending and descending order:
        `created`

        Include parameters can be provided to get the following related resource data: `variants`

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_item: typing.Union[typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogItemItem], typing.List[GetCatalogCategoryItemsRequestFieldsCatalogItemItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem], typing.List[GetCatalogCategoryItemsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`category.id`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - include: typing.Union[typing.Optional[typing_extensions.Literal["variants"]], typing.List[typing_extensions.Literal["variants"]]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#relationships

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogCategoryItemsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/items"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-item]": fields_catalog_item,
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "include": include,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemResponseCollectionCompoundDocument, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_item_variants(
        self,
        id: str,
        *,
        fields_catalog_variant: typing.Union[
            typing.Optional[GetCatalogItemVariantsRequestFieldsCatalogVariantItem],
            typing.List[GetCatalogItemVariantsRequestFieldsCatalogVariantItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemVariantsRequestSort] = None,
    ) -> GetCatalogVariantResponseCollection:
        """
        Get all variants related to the given item ID.

        Variants can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 variants per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_variant: typing.Union[typing.Optional[GetCatalogItemVariantsRequestFieldsCatalogVariantItem], typing.List[GetCatalogItemVariantsRequestFieldsCatalogVariantItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`sku`: `equals`<br>`title`: `contains`<br>`published`: `equals`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemVariantsRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/variants"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-variant]": fields_catalog_variant,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogVariantResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_item_categories(
        self,
        id: str,
        *,
        fields_catalog_category: typing.Union[
            typing.Optional[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem],
            typing.List[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem],
        ],
        filter: typing.Optional[str] = None,
        page_cursor: typing.Optional[str] = None,
        sort: typing.Optional[GetCatalogItemCategoriesRequestSort] = None,
    ) -> GetCatalogCategoryResponseCollection:
        """
        Get all catalog categories that an item with the given item ID is in.

        Catalog categories can be sorted by the following fields, in ascending and descending order:
        `created`

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - fields_catalog_category: typing.Union[typing.Optional[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem], typing.List[GetCatalogItemCategoriesRequestFieldsCatalogCategoryItem]]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sparse-fieldsets

            - filter: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#filtering<br>Allowed field(s)/operator(s):<br>`ids`: `any`<br>`item.id`: `equals`<br>`name`: `contains`

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination

            - sort: typing.Optional[GetCatalogItemCategoriesRequestSort]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#sorting
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/categories"),
            params=remove_none_from_dict(
                {
                    "fields[catalog-category]": fields_catalog_category,
                    "filter": filter,
                    "page[cursor]": page_cursor,
                    "sort": sort,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_category_relationships_items(
        self, id: str, *, page_cursor: typing.Optional[str] = None
    ) -> GetCatalogCategoryItemListResponseCollection:
        """
        Get all items in the given category ID.

        Returns a maximum of 100 items per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            params=remove_none_from_dict({"page[cursor]": page_cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogCategoryItemListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Create a new item relationship for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Update item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_catalog_category_relationships_items(self, id: str, *, request: CatalogCategoryItemOp) -> None:
        """
        Delete item relationships for the given category ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogCategoryItemOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-categories/{id}/relationships/items"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_catalog_item_relationships_categories(
        self, id: str, *, page_cursor: typing.Optional[str] = None
    ) -> GetCatalogItemCategoryListResponseCollection:
        """
        Get all catalog categories that a particular item is in.

        Returns a maximum of 100 categories per request.<br><br>*Rate limits*:<br>Burst: `350/s`<br>Steady: `3500/m`

        **Scopes:**
        `catalogs:read`

        Parameters:
            - id: str.

            - page_cursor: typing.Optional[str]. For more information please visit https://developers.klaviyo.com/en/v2023-08-15/reference/api-overview#pagination
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            params=remove_none_from_dict({"page[cursor]": page_cursor}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCatalogItemCategoryListResponseCollection, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Create a new catalog category relationship for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Update catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_catalog_item_relationships_categories(self, id: str, *, request: CatalogItemCategoryOp) -> None:
        """
        Delete catalog category relationships for the given item ID.<br><br>*Rate limits*:<br>Burst: `75/s`<br>Steady: `700/m`

        **Scopes:**
        `catalogs:write`

        Parameters:
            - id: str.

            - request: CatalogItemCategoryOp.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/catalog-items/{id}/relationships/categories"
            ),
            json=jsonable_encoder(request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
