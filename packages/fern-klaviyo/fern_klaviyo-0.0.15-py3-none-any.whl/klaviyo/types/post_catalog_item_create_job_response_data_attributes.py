# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .api_job_error_payload import ApiJobErrorPayload
from .post_catalog_item_create_job_response_data_attributes_status import (
    PostCatalogItemCreateJobResponseDataAttributesStatus,
)


class PostCatalogItemCreateJobResponseDataAttributes(pydantic.BaseModel):
    job_id: str = pydantic.Field(description="Unique identifier for retrieving the job. Generated by Klaviyo.")
    status: PostCatalogItemCreateJobResponseDataAttributesStatus = pydantic.Field(
        description="Status of the asynchronous job."
    )
    created_at: dt.datetime = pydantic.Field(
        description="The date and time the job was created in ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm)."
    )
    total_count: int = pydantic.Field(
        description="The total number of operations to be processed by the job. See `completed_count` for the job's current progress."
    )
    completed_count: typing.Optional[int] = pydantic.Field(
        description="The total number of operations that have been completed by the job."
    )
    failed_count: typing.Optional[int] = pydantic.Field(
        description="The total number of operations that have failed as part of the job."
    )
    completed_at: typing.Optional[dt.datetime] = pydantic.Field(
        description="Date and time the job was completed in ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm)."
    )
    errors: typing.Optional[typing.List[ApiJobErrorPayload]] = pydantic.Field(
        description="Array of errors encountered during the processing of the job."
    )
    expires_at: typing.Optional[dt.datetime] = pydantic.Field(
        description="Date and time the job expires in ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm)."
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
