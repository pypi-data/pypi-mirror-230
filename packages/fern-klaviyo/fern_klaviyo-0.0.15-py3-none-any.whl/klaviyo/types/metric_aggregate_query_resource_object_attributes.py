# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .metric_aggregate_query_resource_object_attributes_by_item import (
    MetricAggregateQueryResourceObjectAttributesByItem,
)
from .metric_aggregate_query_resource_object_attributes_interval import (
    MetricAggregateQueryResourceObjectAttributesInterval,
)
from .metric_aggregate_query_resource_object_attributes_measurements_item import (
    MetricAggregateQueryResourceObjectAttributesMeasurementsItem,
)
from .metric_aggregate_query_resource_object_attributes_sort import MetricAggregateQueryResourceObjectAttributesSort


class MetricAggregateQueryResourceObjectAttributes(pydantic.BaseModel):
    metric_id: str = pydantic.Field(description="The metric ID used in the aggregation.")
    page_cursor: typing.Optional[str] = pydantic.Field(
        description="Optional pagination cursor to iterate over large result sets"
    )
    measurements: typing.List[MetricAggregateQueryResourceObjectAttributesMeasurementsItem] = pydantic.Field(
        description="Measurement key, e.g. `unique`, `sum_value`, `count`"
    )
    interval: typing.Optional[MetricAggregateQueryResourceObjectAttributesInterval] = pydantic.Field(
        description='Aggregation interval, e.g. "hour", "day", "week", "month"'
    )
    page_size: typing.Optional[int] = pydantic.Field(
        description="Alter the maximum number of returned rows in a single page of aggregation results"
    )
    by: typing.Optional[typing.List[MetricAggregateQueryResourceObjectAttributesByItem]] = pydantic.Field(
        description="Optional attribute(s) used for partitioning by the aggregation function"
    )
    return_fields: typing.Optional[typing.List[str]] = pydantic.Field(
        description="Provide fields to limit the returned data"
    )
    filter: typing.List[str] = pydantic.Field(
        description=(
            "List of filters, must include time range using ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm).\n"
            "            These filters follow a similar format to those in `GET` requests, the primary difference is that this endpoint asks for a list.\n"
            "            The time range can be filtered by providing a `greater-or-equal` and a `less-than` filter on the `datetime` field.\n"
        )
    )
    timezone: typing.Optional[str] = pydantic.Field(
        description=(
            "The timezone used for processing the query, e.g. `'America/New_York'`.\n"
            "            This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).\n"
            "            While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.\n"
        )
    )
    sort: typing.Optional[MetricAggregateQueryResourceObjectAttributesSort] = pydantic.Field(
        description="Provide a sort key (e.g. -$message)"
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
