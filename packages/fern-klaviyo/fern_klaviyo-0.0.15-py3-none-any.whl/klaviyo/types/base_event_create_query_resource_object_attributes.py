# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ..core.datetime_utils import serialize_datetime
from .base_event_create_query_resource_object_attributes_metric import (
    BaseEventCreateQueryResourceObjectAttributesMetric,
)


class BaseEventCreateQueryResourceObjectAttributes(pydantic.BaseModel):
    properties: typing.Dict[str, typing.Any] = pydantic.Field(
        description=(
            "Properties of this event. Any top level property (that are not objects) can be\n"
            "used to create segments. The $extra property is a special property. This records any\n"
            "non-segmentable values that can be references later. For example, HTML templates are\n"
            "useful on a segment, but itself is not used in creating a segment. There are limits\n"
            "placed onto the size of the data present. This must not exceed 5 MB. This must not\n"
            "exceed 300 event properties. A single string cannot be larger than 100 KB. Each array\n"
            "must not exceed 4000 elements. The properties cannot contain more than 10 nested levels.\n"
        )
    )
    time: typing.Optional[dt.datetime] = pydantic.Field(
        description=(
            "When this event occurred. By default, the time the request was received will be used.\n"
            "The time is truncated to the second. The time must be after the year 2000 and can only\n"
            "be up to 1 year in the future.\n"
        )
    )
    value: typing.Optional[float] = pydantic.Field(
        description="A numeric value to associate with this event. For example, the dollar amount of a purchase."
    )
    unique_id: typing.Optional[str] = pydantic.Field(
        description=(
            "A unique identifier for an event. If the unique_id is repeated for the same\n"
            "profile and metric, only the first processed event will be recorded. If this is not\n"
            "present, this will use the time to the second. Using the default, this limits only one\n"
            "event per profile per second.\n"
        )
    )
    metric: BaseEventCreateQueryResourceObjectAttributesMetric

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
