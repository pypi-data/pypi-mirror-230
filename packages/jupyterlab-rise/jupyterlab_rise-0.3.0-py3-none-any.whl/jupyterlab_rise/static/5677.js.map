{"version":3,"file":"5677.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/mimerenderers.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._deferred = new Array();\n        this._deferredMainArea = null;\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._mode = 'multiple-document';\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        if (options.mode) {\n            this._mode = options.mode;\n        }\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * Whether full layout restoration is deferred and is currently incomplete.\n     *\n     * #### Notes\n     * This flag is useful for tracking when the application has started in\n     * 'single-document' mode and the main area has not yet been restored.\n     */\n    get isDeferred() {\n        return this._deferred.length > 0;\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            downArea: null,\n            leftArea: null,\n            rightArea: null,\n            relativeSizes: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, down, left, right, relativeSizes } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            let mainArea = null;\n            if (this._mode === 'multiple-document') {\n                mainArea = this._rehydrateMainArea(main);\n            }\n            else {\n                this._deferredMainArea = main;\n            }\n            // Rehydrate down area.\n            const downArea = this._rehydrateDownArea(down);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return {\n                fresh,\n                mainArea,\n                downArea,\n                leftArea,\n                rightArea,\n                relativeSizes: relativeSizes || null\n            };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    async restore(tracker, options) {\n        if (this._firstDone) {\n            throw new Error('restore() must be called before `first` has resolved.');\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            throw new Error(`The tracker \"${namespace}\" is already restored.`);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        if (this._mode == 'multiple-document') {\n            const promise = tracker\n                .restore({\n                args: args || (() => JSONExt.emptyObject),\n                command,\n                connector: this._connector,\n                name,\n                registry: this._registry,\n                when: when ? [first].concat(when) : first\n            })\n                .catch(error => {\n                console.error(error);\n            });\n            this._promises.push(promise);\n            return promise;\n        }\n        tracker.defer({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        });\n        this._deferred.push(tracker);\n    }\n    /**\n     * Restore the application layout if its restoration has been deferred.\n     *\n     * @returns - the rehydrated main area.\n     */\n    async restoreDeferred() {\n        if (!this.isDeferred) {\n            return null;\n        }\n        // Empty the deferred list and wait for all trackers to restore.\n        const wait = Promise.resolve();\n        const promises = this._deferred.map(t => wait.then(() => t.restore()));\n        this._deferred.length = 0;\n        await Promise.all(promises);\n        // Rehydrate the main area layout.\n        return this._rehydrateMainArea(this._deferredMainArea);\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(data) {\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        // Save the cached main area layout if restoration is deferred.\n        dehydrated.main = this.isDeferred\n            ? this._deferredMainArea\n            : this._dehydrateMainArea(data.mainArea);\n        dehydrated.down = this._dehydrateDownArea(data.downArea);\n        dehydrated.left = this._dehydrateSideArea(data.leftArea);\n        dehydrated.right = this._dehydrateSideArea(data.rightArea);\n        dehydrated.relativeSizes = data.relativeSizes;\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Reydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a down area description into a serializable object.\n     */\n    _dehydrateDownArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = {\n            size: area.size\n        };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateDownArea(area) {\n        var _a;\n        if (!area) {\n            return { currentWidget: null, size: 0.0, widgets: null };\n        }\n        const internal = this._widgets;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            currentWidget: currentWidget,\n            size: (_a = area.size) !== null && _a !== void 0 ? _a : 0.0,\n            widgets: widgets\n        };\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = { collapsed: area.collapsed };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Reydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a;\n        if (!area) {\n            return { collapsed: true, currentWidget: null, widgets: null };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application:mimedocument',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = Object.assign(Object.assign({}, ft), { icon: LabIcon.resolve({ icon: ft.icon }) });\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map"],"names":["ILayoutRestorer","Token","KEY","LayoutRestorer","constructor","options","this","_deferred","Array","_deferredMainArea","_firstDone","_promisesDone","_promises","_restored","PromiseDelegate","_trackers","Set","_widgets","Map","_mode","_connector","connector","_first","first","_registry","registry","mode","then","Promise","all","clear","resolve","isDeferred","length","restored","promise","add","widget","name","Private","nameProperty","set","disposed","connect","_onWidgetDisposed","async","blank","fresh","mainArea","downArea","leftArea","rightArea","relativeSizes","layout","fetch","data","main","down","left","right","_rehydrateMainArea","_rehydrateDownArea","_rehydrateSideArea","error","tracker","Error","namespace","has","args","command","when","widgetAdded","_","widgetName","widgetUpdated","restore","JSONExt","concat","catch","console","push","defer","wait","promises","map","t","save","warning","warn","reject","dehydrated","_dehydrateMainArea","_dehydrateDownArea","_dehydrateSideArea","area","serializeMain","deserializeMain","size","currentWidget","current","get","widgets","filter","_a","internal","isArray","collapsed","delete","serializeArea","type","currentIndex","orientation","sizes","children","deserializeArea","names","hydrated","child","AttachedProperty","create","owner","dock","IMimeDocumentTracker","createRendermimePlugins","extensions","plugins","WidgetTracker","forEach","mod","default","hasOwnProperty","item","createRendermimePlugin","id","optional","provides","autoStart","activate","app","restorer","path","context","factory","factoryNameProperty","requires","IRenderMimeRegistry","ITranslator","rendermime","translator","undefined","rank","addFactory","rendererFactory","documentWidgetFactoryOptions","docRegistry","fileTypes","ft","icon","Object","assign","LabIcon","addFileType","option","toolbarFactory","w","content","renderer","MimeDocumentFactory","renderTimeout","dataType","modelName","primaryFileType","getFileType","defaultFor","defaultRendered","addWidgetFactory","widgetCreated","sender","pathChanged"],"sourceRoot":""}