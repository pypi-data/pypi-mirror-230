// ---------- Ptr ++/--/+=/-=


ns hex {
    //  Time Complexity: 9@+14
    // Space Complexity: w(0.375@ + 3.25)  + 5@+55  (for log(w) in 16,32,64,128)
    //   ptr[:w/4] += 2w
    // @requires hex.add.init (or hex.init)
    def ptr_inc ptr {
        hex.add_constant w/4, ptr, dw
    }

    //  Time Complexity: 9@+23
    // Space Complexity: w(0.375@ + 3.25)  + 5@+67  (for log(w) in 16,32,64,128)
    //   ptr[:w/4] -= 2w
    // @requires hex.sub.init (or hex.init)
    def ptr_dec ptr {
        hex.sub_constant w/4, ptr, dw
    }

    //  Time Complexity: 13@+26
    // Space Complexity: w(0.375@ + 3.25) + 7.5@+94
    //   ptr[:w/4] += value * 2w    (advance ptr by value)
    // @requires hex.add.init (or hex.init)
    // @note: The complexity is calculated with n_const=2, and for log(w) in 16,32,64,128.
    def ptr_add ptr, value {
        hex.add_constant w/4, ptr, value * dw
    }

    //  Time Complexity: 13@+35
    // Space Complexity: w(0.375@ + 3.25)  + 7.5@+106
    //   ptr[:w/4] -= value * 2w    (retreat ptr by value)
    // @requires hex.add.init (or hex.init)
    // @note: The complexity is calculated with n_const=2, and for log(w) in 16,32,64,128.
    def ptr_sub ptr, value {
        hex.sub_constant w/4, ptr, value * dw
    }
}



// ---------- Stack


ns hex {
    //  Time Complexity: 9@+14
    // Space Complexity: w(0.375@ + 3.25)  + 5@+55
    //   Like:  sp++
    def sp_inc < hex.pointers.sp {
        .ptr_inc hex.pointers.sp
    }

    //  Time Complexity: 9@+23
    // Space Complexity: w(0.375@ + 3.25)  + 5@+67
    //   Like:  sp--
    def sp_dec < hex.pointers.sp {
        .ptr_dec hex.pointers.sp
    }

    //  Time Complexity: 13@+26
    // Space Complexity: w(0.375@ + 3.25) + 7.5@+94
    //   Like:  sp += value
    def sp_add value < hex.pointers.sp {
        .ptr_add hex.pointers.sp, value
    }

    //  Time Complexity: 13@+35
    // Space Complexity: w(0.375@ + 3.25)  + 7.5@+106
    //   Like:  sp -= value
    def sp_sub value < hex.pointers.sp {
        .ptr_sub hex.pointers.sp, value
    }

    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 4w@  (actually a bit smaller)
    //   Like:  stack[++sp] = return_address
    //   Pushes the given return_address to the next cell in the stack (assumes it's zero). Increments sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def push_ret_address return_address < hex.pointers.sp {
        .sp_inc
        .ptr_wflip_2nd_word hex.pointers.sp, return_address
    }

    //  Time Complexity: 4w@  (actually a bit smaller)
    // Space Complexity: 4w@  (actually a bit smaller)
    //   Like:  stack[sp--] = 0
    //   Pops the given return_address from the current cell in the stack (assumes it has the value of the return_address). Decrements sp.
    // return_address is a fj-op address, so we assume is dw-aligned.
    def pop_ret_address return_address < hex.pointers.sp {
        .ptr_wflip_2nd_word hex.pointers.sp, return_address
        .sp_dec
    }


    //  Time Complexity: w(0.5@+2)      + 14@+26
    // Space Complexity: w(0.875@+5.25) + 10@+131
    //   Like:  stack[++sp] = hex    (assumes  stack[++sp] == 0  beforehand, which the stack-macros guarantee).
    //   Pushes the given hex to the next cell in the stack (assumes it's zero). Increments sp.
    def push hex < hex.pointers.sp {
        .sp_inc
        .xor_to_ptr hex.pointers.sp, hex
    }

    //  Time Complexity: n(w(0.5@+2)      + 14@+26)
    // Space Complexity: n(w(0.875@+5.25) + 10@+131)
    //   Like:  stack[sp+1:][:n] = hex[:n];  sp += n    (assumes  stack[sp:sp+n] == 0  beforehand, which the stack-macros guarantee).
    //   Pushes the given hex[:n] to the next n cells in the stack (assumes they're zero). Increments sp by n.
    def push n, hex {
        rep(n, i) .push hex+i*dw
    }


    //  Time Complexity: w(0.5@+2)       + 14@+35
    // Space Complexity: w(0.875@+17.25) + 10@+143
    //   Like:  stack[sp--] = 0   (assumes  stack[sp] == unchanged_hex  beforehand)
    //   Pops the given unchanged_hex (a hex) from the current cell in the stack (assumes it has the exact value of hex). Decrements sp.
    def pop_unchanged_parameter unchanged_hex < hex.pointers.sp {
        .xor_to_ptr hex.pointers.sp, unchanged_hex
        .sp_dec
    }

    //  Time Complexity: n(w(0.5@+2)       + 14@+35)
    // Space Complexity: n(w(0.875@+17.25) + 10@+143)
    //   Like:  sp -= n;  stack[sp+1:][:n] = 0   (assumes  stack[sp+1-n:][:n] == unchanged_hex[:n]  beforehand)
    //   Pops the given unchanged_hex (a hex[:n]) from the current cell in the stack (assumes it has the exact value of hex). Decrements sp by n.
    def pop_unchanged_parameter n, unchanged_hex {
        rep(n, i) .pop_unchanged_parameter unchanged_hex+i*dw
    }


    //  Time Complexity: w(6@+10)   (for w=64. exact: w(5@+10)        + 15@+43  + 2(@-2)^2)
    // Space Complexity: w(6.5@+20) (for w=64. exact: w(5.375@+25.25) + 11@+173 + 2(@-2)^2)
    //   Like:  hex = stack[sp]
    //          stack[sp--] = 0
    //   Pops the current stack cell into the the given hex. Decrements sp.
    // hex is only an output parameter
    def pop hex < hex.pointers.sp {
        hex.zero hex
        .xor_from_ptr hex, hex.pointers.sp
        .pop_unchanged_parameter hex
    }

    //  Time Complexity: nw(6@+10)   (for w=64. exact/n is: w(5@+10)        + 15@+43  + 2(@-2)^2)
    // Space Complexity: nw(6.5@+20) (for w=64. exact/n is: w(5.375@+25.25) + 11@+173 + 2(@-2)^2)
    //   Like:  sp -= n
    //          hex[:n] = stack[sp+1][:n]
    //          stack[sp+1:][:n] = 0
    //   Pops the current stack cell into the the given hex[:n]. Decrements sp by n.
    // hex[:n] is only an output parameter.
    def pop n, hex {
        rep(n, i) .pop hex+(n-1-i)*dw
    }
}
