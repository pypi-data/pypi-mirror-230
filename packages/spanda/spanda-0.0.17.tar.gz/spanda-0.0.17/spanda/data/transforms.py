# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/04_data.transforms.ipynb.

# %% ../../nbs/04_data.transforms.ipynb 3
from __future__ import annotations
from math import sqrt, ceil

from fastai.vision.all import *
from fastai.data.all import *
from fastcore.basics import patch
from pathlib import Path
import pandas as pd
import torchvision.transforms as T

from sklearn.base import BaseEstimator, TransformerMixin
from scipy.spatial import ConvexHull
from scipy.interpolate import interp1d
from scipy.signal import savgol_filter

from ..readers import read_asd

from tqdm import tqdm

# %% auto 0
__all__ = ['Spectra', 'SpectraTfm', 'SpectraBlock', 'ToAbsorbanceTfm', 'RandWAvgTfm', 'AvgTfm', 'DerivTfm', 'NormalizeTfm',
           'TrimTfm', 'SNVTfm', 'GADFTfm', 'ResizeTfm', 'To3DTfm', 'RandomCropTfm', 'Analytes', 'AnalytesTfm',
           'AnalytesBlock', 'LogTfm', 'asTabular', 'ContinuumRemoval']

# %% ../../nbs/04_data.transforms.ipynb 13
class Spectra(Tensor):
    "A 'showable' spectra class subclassing torch.Tensor"
    domain = domain_name = light = None
        
    def show(self, ctx=None, wn=np.arange(4000, 600, -2), figsize=(8,2), **kwargs):
        spectra = self
        if ctx is None: _,ctx = plt.subplots(figsize=figsize)
        
        if Spectra.domain_name == 'wavenumber':
            ctx.set_xlim(np.max(Spectra.domain), np.min(Spectra.domain))

        ctx.set(xlabel=Spectra.domain_name.capitalize() + ' →', 
                ylabel=Spectra.light.capitalize())
        
        ctx.set_xlabel(Spectra.domain_name.capitalize() + '→', loc='right')
        ctx.set_ylabel(Spectra.light.capitalize() + ' →', loc='top')
        
        ctx.set_axisbelow(True)
        for spectrum in spectra:
            _ = ctx.plot(Spectra.domain, spectrum, c='steelblue', lw=1)
        ctx.grid(True, which='both')
        return ctx
    
    @classmethod
    def reset(cls):
        cls.domain = cls.domain_name = cls.light = None

# %% ../../nbs/04_data.transforms.ipynb 14
class SpectraTfm(Transform):
    "Transform folder path into a torch array of dimension: (n_replicates, n_wavenumbers)"        
    def __init__(self):
        Spectra.reset()
    
    def encodes(self, 
                o:L # list of spectrum replicates
               ):
        n, m  = len(pd.read_csv(o[0])), len(o)
        x = np.empty((m,n))
        for i, fname in enumerate(o):
            df = pd.read_csv(fname)
            if Spectra.light is None:
                Spectra.domain_name, Spectra.light = df.columns
                Spectra.domain = df[Spectra.domain_name].values
            x[i,:] = df[Spectra.light].values
        return Spectra(torch.Tensor(x)) 

# %% ../../nbs/04_data.transforms.ipynb 16
def SpectraBlock():
    return TransformBlock(type_tfms=SpectraTfm())

# %% ../../nbs/04_data.transforms.ipynb 18
class ToAbsorbanceTfm(Transform):
    "Transform spectra replicates taking their average"
    def encodes(self, x:Spectra):
        return torch.log10(x)

# %% ../../nbs/04_data.transforms.ipynb 19
class RandWAvgTfm(Transform):
    "Transform spectra replicates taking their random weighted averages for data augmentation"
    def encodes(self, x:Spectra):
        n = len(x)
        return torch.matmul(self._weights(n), x)  
    def _weights(self, n):
        weights = torch.rand(n)
        return (weights/weights.sum()).unsqueeze(dim=0)

# %% ../../nbs/04_data.transforms.ipynb 20
class AvgTfm(Transform):
    "Transform spectra replicates taking their average"
    def encodes(self, x:Spectra):
        return torch.mean(x, dim=0, keepdim=True)

# %% ../../nbs/04_data.transforms.ipynb 21
class DerivTfm(Transform):
    def __init__(self, window_length=11, polyorder=1, deriv=1):
        self.window_length = window_length
        self.polyorder = polyorder
        self.deriv = deriv
        
    def encodes(self, 
                x:Spectra
               ):
        x = savgol_filter(x.detach().numpy(), 
                          self.window_length, self.polyorder, self.deriv)
        return Spectra(torch.Tensor(x))

# %% ../../nbs/04_data.transforms.ipynb 22
class NormalizeTfm(Transform):
    def __init__(self, mean, std):
        self.mean = mean
        self.std = std
    def encodes(self, x:Spectra):
        return (x - self.mean)/self.std

# %% ../../nbs/04_data.transforms.ipynb 23
# TBR
class TrimTfm(Transform):
    def encodes(self, 
                x:Spectra
               ):
        val = x[:,1675]
        x[:,1675:] = val
        return x

# %% ../../nbs/04_data.transforms.ipynb 25
class SNVTfm(Transform):
    "Standard Normal Variate Transform of input spectrum"
    def encodes(self, x:Spectra):
        mean, std = torch.mean(x, dim=2, keepdim=True), torch.std(x, dim=2, keepdim=True)
        return (x - mean)/std

# %% ../../nbs/04_data.transforms.ipynb 26
class GADFTfm(Transform): 
    """
    Transform batch of spectra S (B, 1, len(S)) into their Grammian Difference Matrix Field (GADF) of shape (B, 1, H, W)
    
    Notes:
    https://arxiv.org/pdf/1506.00327.pdf
    """
    def __init__(self, neg=True):
        self.neg = neg
        
    def rescale(self, x):
        m = torch.min(x, dim=-1, keepdim=True).values
        M = torch.max(x, dim=-1, keepdim=True).values
        return ((x - M) + (x - m)) / (M - m) if self.neg else (x - m) / (M - m)

    def encodes(self, 
                x:Spectra # Batch of spectra S: (B, 1, len(S))
               ): 
        X, I = self.rescale(x), torch.ones_like(x)
        K = torch.sqrt(I - torch.square(X))
        return (torch.matmul(torch.transpose(K, 1, 2), X) - 
                torch.matmul(torch.transpose(X, 1, 2), K)).unsqueeze_(1)

# %% ../../nbs/04_data.transforms.ipynb 27
class ResizeTfm(Transform):
    def __init__(self, size=256):
        self.size = size
        
    def encodes(self, 
                x:Spectra
               ):
        return T.Resize(self.size)(x)

# %% ../../nbs/04_data.transforms.ipynb 28
class To3DTfm(Transform):
    def __init__(self, n):
        n_channel = n // 3
        self.edge_side = ceil(sqrt(n_channel))
        self.padding = 3*self.edge_side**2 - n - 1
        
    def encodes(self, 
                x:Spectra
               ):
        x = F.pad(x, (1, self.padding), mode='constant')
        return x.view(3, self.edge_side, self.edge_side)

# %% ../../nbs/04_data.transforms.ipynb 32
class RandomCropTfm(Transform):
    def __init__(self, size=256):
        self.size = size
        
    def encodes(self, 
                x:Spectra
               ):
        return T.Resize(self.size)(x.unsqueeze(0))

# %% ../../nbs/04_data.transforms.ipynb 35
class Analytes(Tensor, ShowTitle):
    def __init__(self, ys):
        self.ys = ys
        # Ideally, w'd like to show (idx: 1234 | 725: 0.123 | 433: 0.7) decoded

# %% ../../nbs/04_data.transforms.ipynb 36
class AnalytesTfm(Transform):
    "Transform a folder path into a tensor of soil analyte(s) measurement"
    def __init__(self, 
                 analytes:list|None=None):
        self.analytes = analytes
        
    def encodes(self,
                o:Path # Path to directory containing both spectra and analyte(s) measurement
               ):
        df = pd.read_csv(o, dtype={'analyte': str, 'value': float})
        if self.analytes:
            df = df[df.analyte.isin(self.analytes)]
        return Analytes(df['value'].values)

# %% ../../nbs/04_data.transforms.ipynb 38
def AnalytesBlock(analytes):
    return TransformBlock(type_tfms=AnalytesTfm(analytes))

# %% ../../nbs/04_data.transforms.ipynb 39
class LogTfm(Transform):
    def encodes(self, ys:Analytes):
        return torch.log10(ys)

# %% ../../nbs/04_data.transforms.ipynb 45
def asTabular(dls):
    "Stack torch dataloader batches as numpy array"
    xs, ys = [], []
    for x, y in tqdm(dls):
        xs.append(x)
        ys.append(y)
    return (torch.cat(ds).squeeze().numpy() for ds in (xs, ys))

# %% ../../nbs/04_data.transforms.ipynb 47
class ContinuumRemoval(BaseEstimator, TransformerMixin):
    """Creates continnum removal custom transformer"""

    def __init__(self, wls):
        self.wls = wls

    def fit(self, X, y=None):
        return self

    def transform(self, X, y=None):
        continuum_removed_spectra = np.zeros_like(X)
        
        for i, spectrum in enumerate(tqdm(X)):
            points = np.c_[self.wls, spectrum]
            x, y = points.T
            # trick to exclude lower part of convex hull 
            augmented = np.concatenate([points, [(x[0], np.max(y)+1), (x[-1], np.max(y)+1)]], axis=0)
            hull = ConvexHull(augmented)
            continuum_points = points[np.sort([v for v in hull.vertices if v < len(points)])]
            continuum_function = interp1d(*continuum_points.T)
            continuum_removed_spectra[i, :] = y / continuum_function(x)
    
        return continuum_removed_spectra
