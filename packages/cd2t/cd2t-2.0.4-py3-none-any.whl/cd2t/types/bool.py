from cd2t.types.base import BaseDataType
from cd2t.results import AutogenerationInfo, FindingsList, ValidationFinding
from cd2t.RunTimeEnv import RunTimeEnv
from cd2t.schema import SchemaError


class Bool(BaseDataType):
    customizable = True
    data_type_name = "bool"
    matching_classes = [bool]
    options = [
        # option_name, required, class
        ("autogenerate", False, bool, False),
        ("autogenerate_default", False, bool, None),
        ("allowed_value", False, bool, None),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.autogenerate = False
        self.autogenerate_default = None
        self.allowed_value = None

    def verify_options(self, path: str):
        if self.autogenerate:
            if self.autogenerate_default is None:
                raise SchemaError(
                    "Option required, if autogenerate is enabled",
                    path + "autogenerate_default",
                )
            elif (
                self.allowed_value is not None
                and self.autogenerate_default != self.allowed_value
            ):
                raise SchemaError(
                    "must be equal to 'allowed_value'", path + "autogenerate_default"
                )
        super().verify_options(path)

    def verify_data(self, data: any, path: str, RTE: RunTimeEnv) -> FindingsList:
        FL = FindingsList()
        if self.allowed_value is not None and data != self.allowed_value:
            FL.append(ValidationFinding(path=path, message="Value is not allowed"))
        return FL

    def autogenerate_data(self, data: any, path: str, RTE: RunTimeEnv):
        FL = FindingsList()
        if data is not None or not self.autogenerate:
            return data, FL
        new_value = self.autogenerate_default
        FL.append(
            AutogenerationInfo(
                path=path, message="Autogenerated value is %s" % str(new_value)
            )
        )
        return new_value, FL
