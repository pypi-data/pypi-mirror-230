{
  "description": "os",
  "enable": true,
  "nodes": {
    "show_image": {
      "type": "show_image",
      "category": "function",
      "title": "show_image",
      "tooltip": "Takes an input tensor in CHW layout and display it as an image",
      "externalImports": "from matplotlib import pyplot as plt",
      "sourceCode": "{{indent}}def show_image(img, title=None, cmap=None, figSize=(9, 5)):\n    plt.figure(figsize=figSize)\n    plt.imshow(img, cmap=cmap)\n    plt.title(title)\n    plt.axis('off')\n    plt.show()\n{{indent}}show_image({{{inputs.1}}}, {{{inputs.2}}}, {{{inputs.3}}}, {{{inputs.4}}})\n{{{outputs.0}}}",
      "inputs": {
        "execIn": {
          "title": "execIn",
          "tooltip": "execIn",
          "dataType": "exec",
          "showWidget": false,
          "showTitle": false
        },
        "image": {
          "title": "image",
          "dataType": "image",
          "defaultValue": {
            "dataType": "numpy.ndarray",
            "metadata": [
              {
                "colorChannel": "rgb",
                "isMiniBatched": false,
                "channelOrder": "channelLast",
                "intensityRange": "0-255"
              },
              {
                "colorChannel": "grayscale",
                "isMiniBatched": false,
                "channelOrder": "none",
                "intensityRange": "0-255"
              }
            ]
          },
          "tooltip": "numpy.ndarray[image_height, image_width] | numpy.ndarray[image_height, image_width, 3] | numpy.ndarray[image_height, image_width, 4]"
        },
        "title": {
          "title": "title",
          "dataType": "string",
          "defaultValue": "",
          "tooltip": "title - A title to be set for the image. Default: None."
        },
        "cmap": {
          "title": "cmap",
          "dataType": "string",
          "defaultValue": "viridis",
          "tooltip": "cmap(str, optional) - The registered colormap name in matplotlib used to map scalar data to colors. This parameter is ignored if X is RGB(A)."
        },
        "figSize": {
          "title": "figSize",
          "dataType": "tuple",
          "defaultValue": "(9, 5)",
          "tooltip": "figSize 2-tuple of floats, default: (9, 5) - Figure dimension (width, height) in inches"
        }
      },
      "outputs": {
        "execOut": {
          "title": "execOut",
          "tooltip": "execOut",
          "dataType": "exec",
          "showWidget": false,
          "showTitle": false
        }
      }
    }
  },

  "imageTypeConversion": {
    "numpy.ndarray": {
      "numpy.ndarray": {
        "function_definition": "def ndarray2ndarray(src_image, dest_metadata_list):\n    import numpy as np\n    image = np.copy(src_image[\"value\"])\n    if dest_metadata_list is None:\n        return {\n        \"dataType\": src_image[\"dataType\"],\n        \"value\": image,\n        \"metadata\": src_image['metadata'],\n    }\n    def find_matched_color_channel(src_metadata, dest_metadata_list):\n        # First, try matching the dataType\n        for metadata in dest_metadata_list:\n            if metadata[\"colorChannel\"] == src_metadata[\"colorChannel\"]:\n                return metadata\n\n        # Check for 'grb' or 'gbr' in src and match with 'rgb' or 'gbr' in dest\n        if src_metadata[\"colorChannel\"] in [\"grb\", \"gbr\"]:\n            for metadata in dest_metadata_list:\n                if metadata[\"colorChannel\"] in [\"rgb\", \"gbr\"]:\n                    return metadata\n\n        # If no match found, return the first metadata\n        return dest_metadata_list[0]\n\n    src_metadata = src_image[\"metadata\"]\n    dest_metadata = find_matched_color_channel(src_metadata, dest_metadata_list)\n    if src_metadata.get(\"isMiniBatched\", False):\n        batch_dim = 0\n    else:\n        batch_dim = None\n\n    if (\n        src_metadata[\"colorChannel\"] == \"grayscale\"\n        and dest_metadata[\"colorChannel\"] == \"grayscale\"\n    ):\n        pass\n    elif (\n        src_metadata[\"colorChannel\"] == \"grayscale\"\n        and dest_metadata[\"colorChannel\"] != \"grayscale\"\n    ):\n        if batch_dim is not None:\n            image = np.repeat(image[..., np.newaxis], 3, axis=-1)\n        else:\n            image = np.repeat(image[:, :, np.newaxis], 3, axis=2)\n    elif (\n        src_metadata[\"colorChannel\"] != \"grayscale\"\n        and dest_metadata[\"colorChannel\"] == \"grayscale\"\n    ):\n        if src_metadata[\"channelOrder\"] == \"channelFirst\":\n            if batch_dim is None:\n                if src_metadata[\"colorChannel\"] == \"rgb\":\n                    weights = np.array([0.299, 0.587, 0.114]).reshape(3, 1, 1)\n                else:  # gbr\n                    weights = np.array([0.587, 0.114, 0.299]).reshape(3, 1, 1)\n                image = np.sum(image * weights, axis=0)\n            else:\n                if src_metadata[\"colorChannel\"] == \"rgb\":\n                    weights = np.array([0.299, 0.587, 0.114]).reshape(1, 3, 1, 1)\n                else:\n                    weights = np.array([0.587, 0.114, 0.299]).reshape(1, 3, 1, 1)\n                image = np.sum(weights * weights, axis=1, keepdims=True)\n        else:\n            if batch_dim is not None:\n                if src_metadata[\"colorChannel\"] == \"rgb\":\n                    image = np.dot(image[..., :3], [0.299, 0.587, 0.114])\n                else:  # gbr\n                    image = np.dot(image[..., :3], [0.587, 0.114, 0.299])\n            else:\n                if src_metadata[\"colorChannel\"] == \"rgb\":\n                    image = np.dot(image[:, :3], [0.299, 0.587, 0.114])\n                else:\n                    image = np.dot(image[:, :3], [0.587, 0.114, 0.299])\n\n    elif src_metadata[\"colorChannel\"] == \"gbr\" and dest_metadata[\"colorChannel\"] == \"rgb\":\n        if src_metadata[\"channelOrder\"] == \"channelLast\":\n            if batch_dim is not None:\n                image = image[..., [2, 0, 1]]\n            else:\n                image = image[:, :, [2, 0, 1]]\n        elif src_metadata[\"channelOrder\"] == \"channelFirst\":\n            if batch_dim is not None:\n                image = image[:, [2, 0, 1], :, :]\n            else:\n                image = image[[2, 0, 1], :, :]\n\n    elif src_metadata[\"colorChannel\"] == \"rgb\" and dest_metadata[\"colorChannel\"] == \"gbr\":\n        if src_metadata[\"channelOrder\"] == \"channelLast\":\n            if batch_dim is not None:\n                image = image[..., [1, 2, 0]]\n            else:\n                image = image[:, :, [1, 2, 0]]\n        elif src_metadata[\"channelOrder\"] == \"channelFirst\":\n            if batch_dim is not None:\n                image = image[:, [1, 2, 0], :, :]\n            else:\n                image = image[[1, 2, 0], :, :]\n\n                # Adjust channel order\n    if (\n        src_metadata[\"channelOrder\"] == \"channelFirst\"\n        and dest_metadata[\"channelOrder\"] == \"channelLast\"\n    ):\n        if batch_dim is not None:\n            image = np.transpose(image, (batch_dim, 2, 3, 1))\n        else:\n            image = np.transpose(\n                image, (1, 2, 0)\n            )  # Transpose to (height, width, channels)\n\n    if (\n        src_metadata[\"channelOrder\"] == \"channelLast\"\n        and dest_metadata[\"channelOrder\"] == \"channelFirst\"\n    ):\n        if batch_dim is not None:\n            image = np.transpose(image, (batch_dim, 3, 1, 2))\n        else:\n            image = np.transpose(image, (2, 0, 1))\n\n    # Adjust intensity range\n    if (\n        src_metadata[\"intensityRange\"] == \"0-255\"\n        and dest_metadata[\"intensityRange\"] == \"0-1\"\n    ):\n        image = image / 255.0\n    elif (\n        src_metadata[\"intensityRange\"] == \"0-1\"\n        and dest_metadata[\"intensityRange\"] == \"0-255\"\n    ):\n        image = (image * 255).astype(np.uint8)\n\n    # Handle batched destination image with non-batched source image\n    if dest_metadata.get(\"isMiniBatched\", False) and not src_metadata.get(\n        \"isMiniBatched\", False\n    ):\n        image = np.expand_dims(image, 0)\n    elif not dest_metadata[\"isMiniBatched\"] and src_metadata.get(\"isMiniBatched\", False):\n        image = np.squeeze(image)\n\n    if dest_metadata[\"channelOrder\"] == \"none\":\n        if src_metadata[\"channelOrder\"] == \"channelFirst\":\n            image = image.squeeze()\n\n    # Create destination image with new metadata and converted values\n    dest_image = {\n        \"dataType\": src_image[\"dataType\"],\n        \"value\": image,\n        \"metadata\": dest_metadata,\n    }\n\n    return dest_image",
        "function_name": "ndarray2ndarray"
      },
      "torch.tensor": {
        "function_definition": "def ndarray2tensor(src_image):\n  import torch\n  torch_image = torch.tensor(src_image['value']).clone()\n  return {\n       'dataType': 'torch.tensor',\n        'value': torch_image,\n        'metadata': src_image['metadata']\n  }",
        "function_name": "ndarray2tensor"
      }
    }
  }
}
